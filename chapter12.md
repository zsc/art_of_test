# 第12章：硬件和芯片测试

硬件测试与软件测试有着根本性差异：硬件制造过程中的物理缺陷、永久性故障以及量产需求都带来了独特挑战。芯片内包含数十亿个晶体管，如何高效检测制造缺陷并确保功能正确性，是一个兼具理论深度和实践价值的重要领域。本章将深入探讨硬件测试的理论基础、工程实践和前沿发展。

## 12.1 可测试性设计（DFT）

可测试性设计是在芯片设计阶段就考虑测试需求，通过增加额外的测试结构来提高故障检测能力和测试效率。

### 12.1.1 可测试性的基本概念

**可控制性（Controllability）**：
- 将电路内部节点设置为期望逻辑值的能力
- 通过输入信号控制内部状态
- 量化指标：SCOAP可控制性度量

**可观察性（Observability）**：
- 观察电路内部节点逻辑值的能力  
- 将内部信号传播到输出的能力
- 量化指标：SCOAP可观察性度量

**可测试性度量SCOAP**：
**[SCOAP可测试性度量：结合可控制性和可观察性的定量分析方法，通过递归计算为每个电路节点分配数值评分]**

### 12.1.2 扫描设计

**扫描链原理**：
- 将触发器连接成移位寄存器
- 测试模式下可直接控制和观察寄存器状态
- 大幅提高内部节点的可测试性

**扫描触发器结构**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**全扫描设计优势**：
- 将时序电路测试转化为组合电路测试
- 故障覆盖率可达95%以上
- 测试向量生成简化

**部分扫描策略**：
- 只对关键触发器添加扫描功能
- 平衡测试效果与硬件开销
- 基于可测试性分析选择扫描点

### 12.1.3 测试点插入

**控制点（Control Point）**：
- 在低可控制性节点插入
- 通过额外的与门或或门
- 测试模式下强制节点为指定值

**观察点（Observation Point）**：
- 在低可观察性节点插入
- 将内部信号直接连接到输出
- 增加芯片管脚数量

**智能插入算法**：
- 基于可测试性梯度
- 考虑硬件开销约束
- 优化故障覆盖率提升

### 12.1.4 存储器测试设计

**存储器BIST**：
- 内建的测试算法
- 地址/数据/控制生成器
- 响应分析和压缩

**冗余修复**：
- 备用行列替换故障单元
- 可编程熔丝或反熔丝
- 提高成品率

### 12.1.5 时钟测试设计

**时钟域切换**：
- 测试时钟与功能时钟分离
- 可控的时钟速度
- 时钟门控测试

**延迟测试**：
- 过速时钟检测时序故障
- 时钟抖动容忍度
- 关键路径延迟测量

### 练习 12.1

1. 计算一个简单组合电路的SCOAP可测试性度量。

<details>
<summary>参考答案</summary>

SCOAP可测试性计算示例：

考虑电路：Z = A·B + C·D

**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**可控制性计算（从输入到输出）**：

初始化输入：
- CC0(A) = CC1(A) = 1
- CC0(B) = CC1(B) = 1  
- CC0(C) = CC1(C) = 1
- CC0(D) = CC1(D) = 1

AND1门（A·B）：
- CC0(AND1) = min{CC0(A), CC0(B)} + 1 = min{1,1} + 1 = 2
- CC1(AND1) = CC1(A) + CC1(B) + 1 = 1 + 1 + 1 = 3

AND2门（C·D）：
- CC0(AND2) = min{CC0(C), CC0(D)} + 1 = 2
- CC1(AND2) = CC1(C) + CC1(D) + 1 = 3

OR门（Z）：
- CC0(Z) = CC0(AND1) + CC0(AND2) + 1 = 2 + 2 + 1 = 5
- CC1(Z) = min{CC1(AND1), CC1(AND2)} + 1 = min{3,3} + 1 = 4

**可观察性计算（从输出到输入）**：

初始化输出：
- CO(Z) = 1

反向传播：
OR门到AND门：
- CO(AND1) = CO(Z) + CC0(AND2) + 1 = 1 + 2 + 1 = 4
- CO(AND2) = CO(Z) + CC0(AND1) + 1 = 1 + 2 + 1 = 4

AND门到输入：
- CO(A) = CO(AND1) + CC1(B) + 1 = 4 + 1 + 1 = 6
- CO(B) = CO(AND1) + CC1(A) + 1 = 4 + 1 + 1 = 6
- CO(C) = CO(AND2) + CC1(D) + 1 = 4 + 1 + 1 = 6  
- CO(D) = CO(AND2) + CC1(C) + 1 = 4 + 1 + 1 = 6

**可测试性分析**：
- 所有输入的可观察性相同，无特别难测试的节点
- Z的设0比设1困难（5 vs 4），符合OR门特性
- 总体可测试性良好，无需额外测试点
</details>

2. 设计一个4位计数器的扫描链结构。

<details>
<summary>参考答案</summary>

4位计数器扫描链设计：

**原始计数器结构**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**扫描触发器设计**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**完整扫描链连接**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**控制信号**：
- SE=0：正常功能模式
- SE=1：扫描测试模式

**测试过程**：
1. **扫描载入阶段**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **功能执行阶段**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **扫描卸载阶段**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试向量示例**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**优势**：
- 100%内部状态可控/可观
- 测试向量生成简化
- 可测试任意组合逻辑故障
- 支持延迟故障测试

**开销**：
- 每个FF增加1个2选1MUX
- 额外的扫描控制信号
- 约5-10%面积开销
- 扫描时间开销（4个时钟周期）
</details>

### 进一步研究

- 低功耗扫描设计技术
- 压缩扫描和X-masking
- 3D集成电路的测试挑战
- 人工智能在DFT优化中的应用

## 12.2 内建自测试（BIST）

内建自测试通过在芯片内部集成测试生成和响应分析电路，实现测试的自主化和高效化。

### 12.2.1 BIST基本架构

**核心组件**：
- 测试模式生成器（TPG）
- 待测电路（CUT）
- 响应分析器（RA）
- BIST控制器

**典型BIST流程**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.2.2 伪随机测试生成

**线性反馈移位寄存器（LFSR）**：
- 生成伪随机序列
- 硬件实现简单
- 最大长度序列特性

**LFSR设计要点**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**种子依赖性问题**：
- 全0状态为吸收态
- 需要避免或处理全0种子
- 可采用修正的LFSR结构

**加权伪随机生成**：
- 针对特定故障的偏向生成
- 提高故障检测效率
- 平衡随机性与针对性

### 12.2.3 响应压缩技术

**多输入移位寄存器（MISR）**：
- 将多位响应压缩为固定长度
- 基于线性反馈移位寄存器
- 空间和时间双重压缩

**循环冗余码（CRC）**：
- 基于多项式除法
- 优秀的错误检测能力
- 标准化的生成多项式

**别名问题**：
- 错误响应被压缩为正确签名
- 别名概率：约2^(-n)，n为压缩位数
- 通过增加压缩长度降低风险

**时间压缩考虑**：
- 压缩序列与原始序列的关系
- 错误传播和累积效应
- 最优压缩策略

### 12.2.4 存储器BIST

**存储器故障模型**：
- 固定故障（SAF）：单元固定为0或1
- 转换故障（TF）：无法改变状态
- 耦合故障（CF）：单元间相互影响
- 地址故障：地址译码错误
- 数据保持故障：动态失效

**March算法家族**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**算法复杂度对比**：
- March C-：11n（线性）
- March B：17n
- March A：15n
- GALPAT：n²（平方）

### 12.2.5 逻辑BIST设计

**随机抗性电路**：
- 某些电路对随机测试不敏感
- 需要特定的确定性向量
- 混合BIST策略

**测试点优化**：
- 提高随机测试效果
- 减少随机抗性
- 平衡硬件开销

**多阶段BIST**：
- 第一阶段：伪随机测试
- 第二阶段：确定性补充测试
- 针对剩余故障的特殊处理

### 练习 12.2

1. 设计一个8位LFSR的BIST系统并分析其覆盖率。

<details>
<summary>参考答案</summary>

8位LFSR BIST系统设计：

**LFSR结构**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**完整BIST系统**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**MISR结构**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试流程**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**覆盖率分析**：

理论分析：
- 最大序列长度：2^8 - 1 = 255
- 8位输入空间：256种可能
- 覆盖率：255/256 = 99.6%
- 缺失：全0向量（通常不是问题）

实际考虑：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

典型覆盖率：
- 固定故障：95-98%
- 转换故障：90-95%
- 总体：93-97%

**优化策略**：
1. **多项式选择**：
   - 测试不同本原多项式
   - 选择覆盖率最高的

2. **种子优化**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **混合方法**：
   - LFSR伪随机测试（主要）
   - 确定性向量补充（剩余故障）

**性能指标**：
- 硬件开销：约20-30个逻辑门
- 测试时间：255个时钟周期
- 故障覆盖率：93-97%
- 别名概率：< 2^(-8) = 0.39%
</details>

2. 比较不同存储器测试算法的效果和复杂度。

<details>
<summary>参考答案</summary>

存储器测试算法对比分析：

**1. MATS (Modified Algorithmic Test Sequence)**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：4n
- 检测故障：固定故障、地址故障
- 优点：最简单、最快
- 缺点：故障覆盖有限

**2. March C-**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：11n
- 检测故障：SAF、TF、大部分CF、AF
- 优点：广泛使用、平衡的复杂度/覆盖率
- 缺点：不能检测所有耦合故障

**3. March B**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：17n
- 检测故障：包括March C-的所有故障，plus更多CF
- 优点：更高的故障覆盖率
- 缺点：时间开销更大

**4. March A**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：15n
- 检测故障：类似March B但略少
- 平衡性：介于March C-和March B之间

**5. GALPAT (Galloping Pattern)**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：O(n²)
- 检测故障：几乎所有类型，包括复杂耦合
- 优点：最高的故障检测能力
- 缺点：时间复杂度太高，实用性差

**故障检测能力对比表**：

| 故障类型 | MATS | March C- | March A | March B | GALPAT |
|---------|------|----------|---------|---------|---------|
| 固定故障(SAF) | ✓ | ✓ | ✓ | ✓ | ✓ |
| 转换故障(TF) | ✗ | ✓ | ✓ | ✓ | ✓ |
| 反转耦合(CFin) | ✗ | ✓ | ✓ | ✓ | ✓ |
| 幂等耦合(CFid) | ✗ | ✓ | ✓ | ✓ | ✓ |
| 状态耦合(CFst) | ✗ | 部分 | 部分 | ✓ | ✓ |
| 桥接故障(BF) | ✗ | 部分 | 部分 | ✓ | ✓ |
| 地址故障(AF) | ✓ | ✓ | ✓ | ✓ | ✓ |

**复杂度和时间对比**：

| 算法 | 时间复杂度 | 实际操作数 | 相对时间 |
|------|-----------|-----------|----------|
| MATS | 4n | 4n | 1× |
| March C- | 11n | 11n | 2.75× |
| March A | 15n | 15n | 3.75× |
| March B | 17n | 17n | 4.25× |
| GALPAT | n² | 4n²+2n | 1000×(n=1M) |

**选择策略**：

**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**新兴算法和技术**：

1. **透明BIST**：
   - 在正常操作期间进行测试
   - 不中断系统功能
   - 连续监控内存健康

2. **自适应算法**：
   - 根据发现的故障调整测试策略
   - 机器学习指导的测试生成
   - 实时故障概率评估

3. **并行测试**：
   - 多个内存块同时测试
   - 分区测试策略
   - 减少总测试时间

实践建议：
- 通用应用：March C-
- 高可靠性：March B
- 快速筛选：MATS
- 关键系统：分层混合策略
</details>

### 进一步研究

- 新兴存储技术的测试挑战
- 低功耗BIST设计
- 机器学习在测试优化中的应用
- 在线测试和自修复技术

## 12.3 边界扫描与JTAG

边界扫描是一种标准化的测试技术，通过IEEE 1149.1 JTAG标准，为电路板级和芯片级测试提供了统一的解决方案。

### 12.3.1 JTAG标准概述

**IEEE 1149.1标准**：
- 1990年发布的测试访问端口标准
- Joint Test Action Group的缩写
- 提供标准化的测试接口

**基本概念**：
- 在芯片的每个输入/输出管脚旁增加边界扫描单元
- 形成围绕芯片核心的扫描链
- 通过4线接口控制测试操作

**标准接口信号**：
- TCK（Test Clock）：测试时钟
- TMS（Test Mode Select）：模式选择
- TDI（Test Data In）：测试数据输入
- TDO（Test Data Out）：测试数据输出
- TRST（Test Reset）：测试复位（可选）

### 12.3.2 边界扫描架构

**边界扫描单元（BSC）**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**BSC工作模式**：
- 正常模式：信号正常传输
- 捕获模式：捕获引脚状态到扫描链
- 移位模式：扫描链数据移位
- 更新模式：将扫描数据施加到引脚

**典型BSC结构**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.3.3 测试访问端口（TAP）

**TAP控制器状态机**：
- 16个状态的有限状态机
- 通过TMS信号控制状态转换
- 协调指令和数据的操作

**关键状态**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**指令寄存器（IR）**：
- 存储当前测试指令
- 决定数据寄存器的连接
- 标准指令集和用户指令

### 12.3.4 标准测试指令

**BYPASS指令**：
- 最简单的测试指令
- 创建1位的数据路径
- 用于绕过不需要测试的器件

**SAMPLE/PRELOAD指令**：
- 采样所有边界扫描单元的当前值
- 预加载测试数据到输出单元
- 不干扰正常功能

**EXTEST指令**：
- 外部测试指令
- 控制和观察所有数字引脚
- 用于板级互连测试

**INTEST指令**：
- 内部测试指令
- 通过边界扫描访问内部逻辑
- 实现芯片内部的测试

### 12.3.5 板级测试应用

**互连测试**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试向量生成**：
- 基于网表信息
- 自动生成测试序列
- 故障字典方法

**诊断能力**：
- 精确定位故障位置
- 区分不同故障类型
- 提供修复指导

### 12.3.6 高级JTAG应用

**在系统编程（ISP）**：
- 通过JTAG接口编程Flash
- 固件更新和配置
- 制造阶段的编程

**调试支持**：
- 处理器调试接口
- 实时跟踪功能
- 断点和单步执行

**IEEE 1149.4扩展**：
- 模拟和混合信号测试
- 测试总线标准
- 模拟开关矩阵

### 练习 12.3

1. 设计一个简单的4引脚器件的JTAG边界扫描链。

<details>
<summary>参考答案</summary>

4引脚器件JTAG边界扫描设计：

**器件规格**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**边界扫描单元分配**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**JTAG接口**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**边界扫描链连接**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**输入BSC结构（以A[0]为例）**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**输出BSC结构（以Sum[0]为例）**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**TAP控制器状态**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**指令寄存器定义**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试序列示例**：

1. **功能测试**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **互连测试**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**边界扫描描述语言（BSDL）**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试覆盖率分析**：
- 引脚级短路/开路：100%
- 内部逻辑故障：取决于INTEST向量
- 互连故障：板级100%
- 时序故障：有限（准静态测试）
</details>

2. 分析JTAG在板级测试中的优势和限制。

<details>
<summary>参考答案</summary>

JTAG板级测试分析：

**优势分析**：

1. **标准化和互操作性**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **非侵入式测试**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **高故障诊断能力**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

4. **成本效益**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**限制分析**：

1. **测试速度限制**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **故障覆盖范围**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **器件依赖性**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

4. **复杂性管理**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**性能对比表**：

| 测试方面 | JTAG | ICT | 功能测试 | 飞针测试 |
|---------|------|-----|---------|----------|
| 互连覆盖 | 90-95% | 95-99% | 0-30% | 95-99% |
| 故障诊断 | 优秀 | 良好 | 一般 | 优秀 |
| 测试速度 | 慢 | 快 | 中等 | 慢 |
| 治具成本 | 低 | 高 | 中等 | 低 |
| 设置时间 | 短 | 长 | 中等 | 短 |
| 编程复杂度 | 中等 | 低 | 高 | 中等 |

**最佳应用场景**：

1. **适合JTAG的场景**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **不适合的场景**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**混合测试策略**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**结论**：
JTAG是板级测试的重要工具，特别适合现代高密度电路板。虽然有速度和覆盖范围的限制，但其标准化、成本效益和诊断能力使其成为测试策略的核心组件。最佳实践是将JTAG与其他测试方法结合，发挥各自优势。
</details>

### 进一步研究

- IEEE 1149.1的后续标准发展
- 高速信号的边界扫描技术
- 嵌入式仪器标准（IEEE 1149.4/.6/.7）
- JTAG在安全和调试中的应用

## 12.4 故障模型

硬件故障模型是测试向量生成和故障覆盖率评估的理论基础。不同的物理缺陷在逻辑层面表现为不同的故障模型。

### 12.4.1 固定故障模型

**单固定故障（Single Stuck-At Fault, SAF）**：
- 信号线固定为逻辑0（sa0）或逻辑1（sa1）
- 经典且最重要的故障模型
- 对应多种物理缺陷

**物理对应关系**：
- 金属线开路→输入sa0/sa1
- 晶体管漏极开路→输出sa0
- 电源短路→sa1
- 接地短路→sa0

**故障数量计算**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**检测条件**：
为检测线路L的sa0故障：
1. 将L设置为1（激活）
2. 将故障效应传播到输出（传播）
3. 在输出观察到差异

### 12.4.2 桥接故障模型

**桥接故障定义**：
- 两条或多条信号线意外连接
- 反映实际制造中的金属桥接缺陷
- 比固定故障更真实

**桥接故障类型**：

1. **主导桥接（Dominant Bridging）**：
   - 一个信号主导另一个
   - 通常强驱动覆盖弱驱动

2. **线与桥接（Wired-AND）**：
   - 桥接结果为两信号的逻辑与
   - 任一信号为0，结果为0

3. **线或桥接（Wired-OR）**：
   - 桥接结果为两信号的逻辑或
   - 任一信号为1，结果为1

**桥接故障检测**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.4.3 延迟故障模型

**延迟故障类型**：

1. **路径延迟故障（Path Delay Fault）**：
   - 整条路径延迟超过时钟周期
   - 反映路径上所有门的累积延迟

2. **转换延迟故障（Transition Delay Fault）**：
   - 单个门的延迟故障
   - 慢速上升（slow-to-rise）
   - 慢速下降（slow-to-fall）

3. **门延迟故障（Gate Delay Fault）**：
   - 特定门的输入到输出延迟异常
   - 可以是特定输入的延迟

**延迟故障检测**：
- 需要两个时间帧的向量对
- V1：初始化路径为稳定值
- V2：启动转换并在时钟边沿观察

**at-speed测试**：
- 使用功能时钟频率
- 检测实际工作条件下的时序故障
- 比静态测试更真实

### 12.4.4 IDDQ测试

**静态电流测试原理**：
- CMOS电路静态时电流应该很小（nA级）
- 某些故障导致异常电流（mA级）
- 通过测量电源电流检测故障

**可检测故障**：
- 栅极氧化层短路
- 漏极/源极桥接
- 某些固定故障
- 亚阈值泄漏

**IDDQ测试挑战**：
- 工艺技术缩小导致泄漏电流增大
- 深亚微米工艺中应用受限
- 需要特殊的测试设备

### 12.4.5 存储器故障模型

**单元故障**：
- 固定故障：单元固定为0或1
- 转换故障：无法从0变1或从1变0
- 数据保持故障：动态失效

**耦合故障**：
- 反转耦合：一个单元影响另一个单元状态
- 幂等耦合：写操作影响邻近单元
- 状态耦合：读操作影响其他单元

**地址故障**：
- 地址译码器故障
- 访问错误单元
- 多个单元同时被选中

### 练习 12.4

1. 设计测试向量检测一个2输入与门的所有固定故障。

<details>
<summary>参考答案</summary>

2输入与门固定故障分析：

**电路：Z = A · B**

**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**故障列表**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**故障检测分析**：

1. **A sa0故障**：
   - 故障电路：Z = 0 · B = 0
   - 正常电路：Z = A · B
   - 检测条件：需要A=1，且使正常输出≠0
   - 检测向量：A=1, B=1 → 正常输出Z=1，故障输出Z=0

2. **A sa1故障**：
   - 故障电路：Z = 1 · B = B
   - 正常电路：Z = A · B
   - 检测条件：需要A=0，使A·B≠B
   - 检测向量：A=0, B=1 → 正常输出Z=0，故障输出Z=1

3. **B sa0故障**：
   - 故障电路：Z = A · 0 = 0
   - 检测向量：A=1, B=1 → 正常输出Z=1，故障输出Z=0

4. **B sa1故障**：
   - 故障电路：Z = A · 1 = A
   - 检测向量：A=1, B=0 → 正常输出Z=0，故障输出Z=1

5. **Z sa0故障**：
   - 故障电路：Z = 0（无论输入如何）
   - 检测条件：正常输出为1
   - 检测向量：A=1, B=1 → 正常输出Z=1，故障输出Z=0

6. **Z sa1故障**：
   - 故障电路：Z = 1（无论输入如何）
   - 检测条件：正常输出为0
   - 检测向量：A=0, B=0 → 正常输出Z=0，故障输出Z=1
   - 或者：A=0, B=1 → 正常输出Z=0，故障输出Z=1
   - 或者：A=1, B=0 → 正常输出Z=0，故障输出Z=1

**测试向量集合**：

完整测试向量（4个向量，覆盖所有故障）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**最小测试向量集**：

分析哪些向量是必需的：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

最小向量集（3个向量）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**故障覆盖表**：

| 向量 | A | B | Z正常 | A sa0 | A sa1 | B sa0 | B sa1 | Z sa0 | Z sa1 |
|------|---|---|-------|-------|-------|-------|-------|-------|-------|
| V1   | 0 | 1 | 0     | -     | ✓     | -     | ✓     | -     | ✓     |
| V2   | 1 | 0 | 0     | -     | -     | -     | ✓     | -     | ✓     |  
| V3   | 1 | 1 | 1     | ✓     | -     | ✓     | -     | ✓     | -     |

**验证**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**通用结论**：
- 与门的完整故障检测需要至少3个向量
- 包含真值表中能产生1的输入组合（检测sa0故障）
- 包含能产生0的输入组合（检测sa1故障）
- 每个输入都要在0和1状态下测试
</details>

2. 分析为什么延迟故障比固定故障更难检测。

<details>
<summary>参考答案</summary>

延迟故障检测困难性分析：

**1. 检测条件复杂性**

固定故障检测：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障检测：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**2. 路径敏化问题**

固定故障：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**3. 时序复杂性**

固定故障（静态）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障（动态）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**4. 故障传播问题**

固定故障传播：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障传播：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**5. 向量生成复杂度**

固定故障ATPG：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障ATPG：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**6. 测试成本**

固定故障测试：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障测试：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**7. 诊断复杂性**

固定故障诊断：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障诊断：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**结论**：

延迟故障检测困难的根本原因：
1. **维度增加**：从空间（逻辑）扩展到时间（时序）
2. **约束复杂**：多个相互关联的约束条件
3. **连续性**：延迟是连续参数，不是离散逻辑值
4. **工艺敏感**：受制造工艺变化影响大
5. **设备要求**：需要复杂昂贵的测试设备

这解释了为什么业界仍以固定故障为主要测试目标，延迟故障测试主要用于关键应用和高性能电路。
</details>

### 进一步研究

- 纳米工艺中的新兴故障模型
- 软错误和单粒子翻转
- 老化相关的故障机制
- 机器学习在故障建模中的应用

## 12.5 自动测试图案生成（ATPG）

自动测试图案生成是硬件测试的核心技术，通过算法自动生成能够检测特定故障的测试向量。

### 12.5.1 ATPG问题定义

**基本问题**：
给定电路和故障列表，自动生成测试向量集合，使得：
- 最大化故障覆盖率
- 最小化测试向量数量
- 满足时间和计算资源约束

**问题复杂性**：
- NP完全问题
- 搜索空间：2^n（n为输入数）
- 需要启发式算法

### 12.5.2 D算法

**基本思想**：
- 将故障激活和传播问题转化为逻辑约束求解
- 使用D代数扩展常规逻辑
- 系统化搜索测试向量

**D代数**：
- 0, 1：正常逻辑值
- D：正常为1，故障为0
- D̄：正常为0，故障为1
- X：未知值

**D算法步骤**：
1. **故障激活**：在故障位置产生D或D̄
2. **D传播**：将D值传播到主输出
3. **线路赋值**：设置其他输入以保证传播
4. **一致性检查**：验证赋值无矛盾

**D传播规则**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.5.3 FAN算法

**改进动机**：
- D算法回溯次数过多
- 需要更智能的搜索策略
- 提高算法效率

**关键改进**：

1. **多重回溯**：
   - 同时尝试多个赋值
   - 避免过早的错误决策
   - 减少回溯深度

2. **唯一敏化**：
   - 优先选择唯一敏化路径
   - 减少搜索分支
   - 提高成功概率

3. **头线识别**：
   - 找出影响多个目标的关键线路
   - 优先处理头线
   - 加速收敛

**FAN算法流程**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.5.4 基于SAT的ATPG

**SAT建模优势**：
- 将ATPG问题转化为布尔可满足性问题
- 利用现代SAT求解器的强大能力
- 处理复杂约束和优化目标

**编码方法**：

1. **电路结构编码**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **故障效应编码**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **时间帧展开**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.5.5 压缩测试

**动机**：
- 测试向量数量巨大
- 测试时间和存储成本高
- 需要减少测试数据量

**压缩技术**：

1. **测试向量压缩**：
   - 线性反馈移位寄存器（LFSR）
   - 种子压缩
   - 统计编码

2. **响应压缩**：
   - 多输入移位寄存器（MISR）
   - 循环冗余码（CRC）
   - 时间和空间压缩

3. **X值处理**：
   - 未知值影响压缩效果
   - X-masking技术
   - X-tolerant压缩

**压缩比计算**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 练习 12.5

1. 使用D算法为一个简单电路生成测试向量。

<details>
<summary>参考答案</summary>

D算法测试向量生成示例：

**目标电路**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

逻辑表达式：Z = (A·B) + (C·D) = E + F

**目标故障**：E线路sa0 (E stuck-at 0)

**D算法求解过程**：

**步骤1：故障激活**
- 故障：E sa0
- 正常情况：E = A·B  
- 故障情况：E = 0
- 激活条件：使A·B = 1，即A=1, B=1
- 故障激活后：E正常=1, E故障=0，表示为E=D

当前赋值：A=1, B=1, E=D

**步骤2：D传播**
- 目标：将E的D值传播到输出Z
- Z = E + F = D + F
- 传播条件：需要F不能掩盖D
- 对于OR门，要传播D，需要F=0
- 因此设置：F = 0

更新赋值：A=1, B=1, E=D, F=0

**步骤3：确定F=0的条件**
- F = C·D = 0
- 满足条件：C=0 或 D=0（或两者都为0）
- 选择：C=0, D=X（D可以是任意值）

更新赋值：A=1, B=1, C=0, D=X, E=D, F=0

**步骤4：计算输出值**
- Z = E + F = D + 0 = D
- 正常电路：Z = 1
- 故障电路：Z = 0
- 检测成功！

**最终测试向量**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**D算法详细追踪表**：

| 步骤 | 操作 | A | B | C | D | E | F | Z | 备注 |
|------|------|---|---|---|---|---|---|---|------|
| 0 | 初始 | X | X | X | X | X | X | X | 全部未知 |
| 1 | 激活E sa0 | 1 | 1 | X | X | D | X | X | A·B=1产生D |
| 2 | 传播到Z | 1 | 1 | X | X | D | 0 | X | F=0确保传播 |
| 3 | 确定F=0 | 1 | 1 | 0 | X | D | 0 | X | C=0使F=0 |
| 4 | 计算输出 | 1 | 1 | 0 | 0 | D | 0 | D | D传播到输出 |

**其他可能的解**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**算法特点总结**：
1. **系统性**：D算法提供了系统化的搜索方法
2. **完备性**：如果存在测试向量，D算法最终能找到
3. **复杂性**：对于大电路，搜索空间仍然很大
4. **优化空间**：可以通过启发式改进（如FAN算法）

**扩展：检测其他故障**：

对于F线路sa1故障：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

这个例子展示了D算法的核心思想：故障激活→差异传播→一致性求解。
</details>

2. 比较传统ATPG和基于SAT的ATPG方法。

<details>
<summary>参考答案</summary>

传统ATPG vs SAT-based ATPG对比分析：

**1. 算法基础**

传统ATPG（D算法/FAN）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

SAT-based ATPG：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**2. 问题建模方式**

传统方法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

SAT方法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**3. 处理复杂性能力对比**

传统ATPG局限性：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

SAT-based优势：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**4. 性能比较**

运行时间：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

内存使用：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**5. 实际应用对比**

工业应用统计：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**6. 混合方案**

现代商业工具通常采用混合策略：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**7. 未来发展趋势**

技术融合：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**选择建议**：

| 场景 | 推荐方法 | 理由 |
|------|----------|------|
| 快速原型 | 传统ATPG | 工具成熟，速度快 |
| 复杂约束 | SAT-based | 约束处理能力强 |
| 大规模电路 | 混合方法 | 平衡效率和能力 |
| 研究新算法 | SAT-based | 易于扩展和实验 |
| 产品化工具 | 混合方法 | 覆盖所有应用场景 |

总结：传统ATPG和SAT-based方法各有优势，现代趋势是智能融合两者，根据具体问题特征选择最适合的方法。
</details>

### 进一步研究

- 量子计算在ATPG中的应用
- 机器学习辅助的测试向量优化
- 安全性意识的测试生成
- 低功耗测试的约束满足

## 本章小结

硬件和芯片测试代表了测试技术的高度工程化应用。本章我们探讨了：

1. **可测试性设计**：通过设计阶段的考虑提高测试效率
2. **内建自测试**：在硬件内部集成测试能力
3. **边界扫描**：标准化的测试接口和方法
4. **故障模型**：从物理缺陷到逻辑抽象的建模
5. **自动测试生成**：算法化的测试向量生成

硬件测试的独特挑战：
- 物理缺陷的多样性
- 制造规模和成本压力
- 实时性能要求
- 永久性故障的严重性

与软件测试的对比：
- 更强调物理层面的故障
- 更注重测试的经济性
- 更依赖专用的测试设备
- 更严格的正确性要求

技术发展趋势：
- 人工智能在测试优化中的应用
- 新兴工艺带来的测试挑战
- 在线测试和自修复技术
- 安全测试的重要性提升

下一章，我们将探讨机器学习系统测试，看看这些传统的测试理念如何适应AI时代的新挑战。