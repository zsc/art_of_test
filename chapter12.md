# 第12章：硬件和芯片测试

硬件测试与软件测试有着根本性差异：硬件制造过程中的物理缺陷、永久性故障以及量产需求都带来了独特挑战。芯片内包含数十亿个晶体管，如何高效检测制造缺陷并确保功能正确性，是一个兼具理论深度和实践价值的重要领域。本章将深入探讨硬件测试的理论基础、工程实践和前沿发展。

## 12.1 可测试性设计（DFT）

可测试性设计是在芯片设计阶段就考虑测试需求，通过增加额外的测试结构来提高故障检测能力和测试效率。

### 12.1.1 可测试性的基本概念

**可控制性（Controllability）**：
- 将电路内部节点设置为期望逻辑值的能力
- 通过输入信号控制内部状态
- 量化指标：SCOAP可控制性度量
- 实践意义：高可控制性意味着更容易激活特定故障
- 影响因素：逻辑深度、扇入扇出、反馈环路、时序约束

**可观察性（Observability）**：
- 观察电路内部节点逻辑值的能力  
- 将内部信号传播到输出的能力
- 量化指标：SCOAP可观察性度量
- 实践意义：高可观察性意味着更容易检测内部故障
- 影响因素：路径长度、逻辑屏蔽、时序关系、输出数量

**可测试性的物理含义**：
- 可控制性差的典型场景：深层嵌套逻辑、大扇入门控、状态机内部节点
- 可观察性差的典型场景：被冗余逻辑覆盖、长传播路径、时序敏感路径
- 工程权衡：可测试性vs面积/功耗/性能的平衡

**可测试性度量SCOAP（Sandia Controllability/Observability Analysis Program）**：
- 第一个广泛采用的可测试性度量方法
- 为每个节点分配6个数值：CC0、CC1（组合可控制性）、SC0、SC1（时序可控制性）、CO、SO（可观察性）
- 递归计算规则：基于电路拓扑结构
- 应用：指导测试点插入、扫描链设计、ATPG优化

**SCOAP度量的实际应用价值**：
- 识别测试瓶颈：SCOAP值异常高的节点需要特别关注
- 优化测试策略：根据可测试性分布调整测试资源分配
- 设计改进指导：在RTL阶段预估和改善可测试性
- 成本效益分析：量化DFT措施的投资回报

**其他可测试性度量方法**：
- COP（Controllability-Observability Product）：简化的乘积度量
- TMEAS：考虑故障检测概率的统计度量
- TESTSCREEN：基于模拟的精确度量
- 信息论度量：基于熵的可测试性评估

**SCOAP计算规则**：
- AND门：CC0 = min{任一输入CC0} + 1, CC1 = Σ(所有输入CC1) + 1
- OR门：CC0 = Σ(所有输入CC0) + 1, CC1 = min{任一输入CC1} + 1
- NOT门：CC0 = CC1(输入) + 1, CC1 = CC0(输入) + 1
- 可观察性反向传播，考虑其他输入的可控制性

**复杂门的SCOAP计算**：
- XOR门：CC0和CC1都需要考虑输入的不同组合
- MUX门：考虑选择信号和数据输入的联合影响
- 三态门：需要考虑高阻态的特殊处理
- 存储元件：时序可控制性需要累积时钟周期

**SCOAP在现代设计中的挑战**：
- 不准确性：忽略了逻辑相关性和时序约束
- 悲观估计：可能高估某些节点的测试难度
- 扩展性：大规模电路的计算复杂度
- 解决方案：增量计算、近似算法、机器学习预测

### 12.1.2 扫描设计

**扫描链原理**：
- 将触发器连接成移位寄存器
- 测试模式下可直接控制和观察寄存器状态
- 大幅提高内部节点的可测试性
- 本质：将时序电路问题转化为组合电路问题

**扫描设计的历史演进**：
- 1973年：Williams和Angell首次提出扫描路径概念
- 1977年：Eichelberger的LSSD（Level Sensitive Scan Design）
- 1980年代：mux-based扫描成为主流
- 1990年代：边界扫描标准化（IEEE 1149.1）
- 2000年后：压缩扫描技术兴起

**扫描触发器结构**：
典型的扫描触发器由普通D触发器和2选1多路选择器组成：
- 功能输入（D）：正常操作模式下的数据输入
- 扫描输入（SI）：扫描模式下的测试数据输入
- 扫描使能（SE）：控制工作模式（0=正常，1=扫描）
- 时钟（CLK）：统一的时钟信号
- 输出（Q）：触发器输出，同时连接到下一级扫描输入

**扫描触发器的实现变体**：
1. **Mux-based扫描触发器**：
   - 最常用，面积开销约8-15%
   - 时序影响小，易于时序收敛
   - 支持多种DFT测试模式

2. **Clock-based扫描触发器**：
   - 使用独立的扫描时钟
   - 面积开销更小（5-10%）
   - 时钟设计复杂度增加

3. **LSSD触发器**：
   - IBM开发的电平敏感设计
   - 更高的鲁棒性，避免竞争冒险
   - 面积开销较大（15-20%）

**扫描操作的三个阶段**：
1. 扫描载入（Scan-in）：SE=1，通过SI串行载入测试向量
2. 功能捕获（Capture）：SE=0，执行一个或多个功能时钟周期
3. 扫描卸载（Scan-out）：SE=1，通过SO串行读出响应

**扫描操作的时序细节**：
- 扫描频率：通常低于功能频率（10-50MHz）
- 时钟域处理：多时钟域需要特殊同步机制
- 功耗考虑：扫描移位时的开关活动率很高
- 优化技术：扫描分段、时钟门控、低功耗扫描

**扫描测试协议**：
1. **基本协议**：shift-capture-shift
2. **增强协议**：支持多捕获周期
3. **诊断协议**：包含特殊的诊断模式
4. **BIST协议**：与内建自测试的协同

**全扫描设计优势**：
- 将时序电路测试转化为组合电路测试
- 故障覆盖率可达95%以上
- 测试向量生成简化
- ATPG工具成熟度高
- 诊断分辨率高

**全扫描的代价分析**：
1. **面积开销**：
   - 扫描触发器：8-15%
   - 布线资源：5-10%
   - 控制逻辑：1-2%
   - 总计：15-25%面积增加

2. **性能影响**：
   - 建立时间增加：50-100ps
   - 功耗增加：测试时2-3倍
   - 关键路径影响：需要careful planning

3. **设计复杂度**：
   - DFT规则检查
   - 时序例外处理
   - 多模式验证

**部分扫描策略**：
- 只对关键触发器添加扫描功能
- 平衡测试效果与硬件开销
- 基于可测试性分析选择扫描点

**部分扫描的选择算法**：
1. **基于可测试性度量**：
   - 选择SCOAP值最差的触发器
   - 迭代改进直到满足目标覆盖率
   - 典型实现：70-80%触发器扫描化

2. **基于结构分析**：
   - 打破反馈环路
   - 减少时序深度
   - 平衡扫描链长度

3. **基于故障模拟**：
   - 增量式故障覆盖率分析
   - 成本效益最优化
   - 考虑实际故障分布

**部分扫描的应用场景**：
- 成本敏感的消费类产品
- 高性能处理器的关键路径
- 混合信号电路的数字部分
- 遗留设计的DFT改造

### 12.1.3 测试点插入

**测试点插入的理论基础**：
- 基于可测试性分析结果
- 目标：以最小硬件开销获得最大故障覆盖率提升
- 典型提升：5-10%的故障覆盖率，2-3%的面积开销

**测试点插入的数学模型**：
- 目标函数：maximize ΔFC/ΔCost
- 约束条件：面积、时序、功耗限制
- 优化算法：贪婪、模拟退火、遗传算法
- 评估指标：ROI（Return on Investment）

**测试点的经济学分析**：
- 插入成本：设计时间、面积、验证工作量
- 收益评估：测试时间减少、良率提升、现场可靠性
- 盈亏平衡点：通常在10M单元产量时回收投资
- 长期价值：降低客户退货率和保修成本

**控制点（Control Point）**：
- 在低可控制性节点插入
- 通过额外的与门或或门实现
- 测试模式下强制节点为指定值
- 两种类型：0-控制点（AND门）和1-控制点（OR门）
- 控制信号通过专用测试寄存器或主输入提供

**控制点的高级实现技术**：
1. **多路复用控制点**：
   - 使用MUX而非AND/OR门
   - 更灵活的控制选项
   - 支持多种测试模式

2. **可编程控制点**：
   - 运行时可配置的控制值
   - 支持自适应测试
   - 减少测试向量数量

3. **时序控制点**：
   - 插入在时序路径上
   - 改善延迟故障检测
   - 需要careful timing analysis

**观察点（Observation Point）**：
- 在低可观察性节点插入
- 将内部信号直接连接到输出
- 增加芯片管脚数量

**观察点的实现策略**：
1. **直接观察**：
   - 专用测试输出引脚
   - 最高观察质量
   - 引脚开销大

2. **压缩观察**：
   - XOR树或MISR压缩
   - 多个信号共享输出
   - 空间-时间权衡

3. **扫描观察**：
   - 通过扫描链观察
   - 无需额外引脚
   - 观察延迟较大

4. **嵌入式观察**：
   - 利用现有功能输出
   - 时分复用技术
   - 最小硬件开销

**智能插入算法**：
- 基于可测试性梯度的贪婪算法
- 成本函数：ΔFC/ΔArea（故障覆盖率提升与面积开销的比值）
- 考虑硬件开销约束：面积、功耗、时序影响
- 优化故障覆盖率提升：目标通常为99%以上
- 迭代优化：每次插入后重新计算可测试性

**先进的测试点选择算法**：
1. **机器学习方法**：
   - 训练数据：历史设计的测试点效果
   - 特征提取：电路拓扑、逻辑深度、扇入扇出
   - 预测模型：随机森林、神经网络
   - 优势：考虑复杂的相互作用

2. **多目标优化**：
   - Pareto最优解集
   - 权衡多个指标：覆盖率、面积、功耗、时序
   - 决策支持：可视化trade-off曲线

3. **增量式优化**：
   - 实时评估每个测试点的边际效益
   - 动态调整插入策略
   - 早期终止条件：收益递减检测

**高级测试点技术**：
- 共享测试点：多个节点共用控制/观察逻辑
- 可编程测试点：运行时可配置的测试结构
- 混合测试点：同时改善可控制性和可观察性

**测试点的创新应用**：
1. **自适应测试点**：
   - 根据制造数据动态调整
   - 机器学习驱动的配置
   - 持续优化测试效率

2. **多功能测试点**：
   - 测试模式：提高可测试性
   - 调试模式：内部信号观察
   - 诊断模式：故障定位
   - 监控模式：在线健康检查

3. **安全测试点**：
   - 防止侧信道泄露
   - 支持安全测试协议
   - 硬件木马检测

**测试点插入的最佳实践**：
- 早期评估：RTL阶段的可测试性预测
- 协同优化：与扫描链设计同步考虑
- 验证策略：确保测试点不影响功能
- 文档管理：详细记录测试点用途和配置

### 12.1.4 存储器测试设计

**存储器测试的特殊挑战**：
- 高密度：现代存储器包含数十亿个单元
- 复杂故障模型：耦合故障、模式敏感故障
- 访问限制：内部结构不可直接访问
- 性能要求：高速测试以检测时序相关故障

**存储器技术演进对测试的影响**：
1. **传统SRAM/DRAM**：
   - 成熟的故障模型和测试算法
   - March算法族效果良好
   - 主要挑战是测试时间

2. **新型非易失性存储器**：
   - ReRAM：电阻切换故障
   - MRAM：磁性翻转故障
   - PCM：相变可靠性问题
   - 需要专门的测试方法

3. **3D存储器架构**：
   - TSV（硅通孔）相关故障
   - 层间耦合效应
   - 热管理挑战
   - 测试访问复杂度增加

**存储器BIST架构**：
- 内建的测试算法：March、Checkerboard、Walking patterns
- 地址生成器：线性、伪随机、特定模式
- 数据生成器：固定模式、伪随机、背景数据
- 控制生成器：读写时序、刷新控制
- 响应分析器：比较器、签名分析器
- 诊断支持：故障位图、修复分析

**存储器BIST的架构创新**：
1. **可编程BIST引擎**：
   - 微代码控制的测试序列
   - 现场可更新的算法
   - 支持新故障模型
   - 减少硅片改版需求

2. **分布式BIST**：
   - 每个存储器块local BIST
   - 层次化的测试控制
   - 并行测试能力
   - 降低全局布线开销

3. **智能BIST控制器**：
   - 自适应测试序列
   - 基于历史数据的优化
   - 早期故障预测
   - 动态修复策略

**BIST与ATE的协同**：
- BIST执行基本功能测试
- ATE提供精确时序测量
- 诊断数据的有效传输
- 测试时间的优化分配

**冗余修复机制**：
- 备用行列设计：典型2-4%的冗余资源
- 故障单元识别：BIST过程中记录故障地址
- 修复算法：最优分配备用资源（NP完全问题）
- 实现技术：
  - 激光熔丝：一次性编程，制造阶段
  - 电熔丝（eFuse）：电编程，可在封装后
  - 反熔丝：高压编程，高可靠性
  - 软修复：配置寄存器，灵活但易失
- 成品率提升：从50%提升到95%以上

**先进的修复算法**：
1. **贪心算法变体**：
   - Must-Repair优先
   - 行列平衡策略
   - 快速但次优
   - 适合在线修复

2. **精确算法**：
   - 分支限界法
   - 二分图匹配
   - 最优解保证
   - 计算复杂度高

3. **启发式方法**：
   - 模拟退火
   - 遗传算法
   - 神经网络预测
   - 平衡质量和速度

**修复策略的经济分析**：
- 冗余开销vs良率提升的权衡
- 不同市场segment的优化策略
- 现场修复能力的价值评估
- 全生命周期的可靠性考虑

**新兴修复技术**：
- 自修复存储器：运行时动态重映射
- 容错编码：ECC与冗余的结合
- 机器学习辅助：预测性维护
- 量子纠错：未来存储技术

### 12.1.5 时钟和电源测试设计

**时钟域管理**：
- 测试时钟与功能时钟分离：避免时钟域交叉问题
- 可控的时钟速度：支持at-speed和slow-speed测试
- 时钟门控测试：确保门控逻辑的可测试性
- 锁相环（PLL）旁路：测试模式下使用外部时钟
- 时钟分频器测试：专门的测试模式

**时钟测试的关键技术**：
1. **OCC（On-Chip Clock）控制器**：
   - 精确的时钟脉冲生成
   - 支持launch-capture测试
   - 可编程的时钟序列
   - 多时钟域同步

2. **时钟校准机制**：
   - 片上时钟质量监测
   - 抖动和偏斜测量
   - 自适应时钟调整
   - 老化补偿

3. **测试时钟架构**：
   - 专用测试时钟网络
   - 低偏斜设计
   - 可测试性与性能平衡
   - 时钟gating的特殊处理

**多时钟域测试**：
- 时钟域隔离：防止亚稳态传播
- 同步器测试：专门的测试结构
- 相位关系控制：确保可预测的时序

**CDC（Clock Domain Crossing）测试**：
1. **同步器验证**：
   - 亚稳态窗口测试
   - MTBF计算和验证
   - 多级同步器检查
   - Gray码传输验证

2. **协议检查**：
   - 握手协议完整性
   - FIFO深度验证
   - 数据一致性测试
   - 死锁检测

3. **时序约束验证**：
   - 建立/保持时间裕量
   - 多周期路径处理
   - 虚假路径识别
   - 约束覆盖率分析

**延迟故障测试支持**：
- Launch-on-Capture (LOC)：使用功能时钟产生转换
- Launch-on-Shift (LOS)：使用扫描时钟产生转换
- 增强扫描（Enhanced Scan）：支持任意两个向量的施加
- On-Chip Clock (OCC) 控制器：精确的时钟脉冲生成
- 时钟抖动补偿：考虑PVT变化的余量设计

**小延迟缺陷（SDD）测试**：
1. **测试策略**：
   - 多检测测试：同一路径多次测试
   - 统计时序测试：多个角落条件
   - N-detect方法：每个故障N次检测
   - 时序余量分析

2. **路径选择**：
   - 关键路径优先
   - 统计时序分析指导
   - 功能相关路径
   - 客户使用模式

3. **测试质量评估**：
   - SDQL（Small Delay Quality Level）
   - 统计故障覆盖率
   - 缺陷逃逸率预测
   - 现场失效相关性

**电源噪声感知测试**：
- 电源下垂（IR-drop）测试
- 同步开关噪声（SSN）考虑
- 低功耗测试模式：降低测试功耗
- 电源门控测试：确保电源域切换正确

**电源完整性测试**：
1. **动态电压降测试**：
   - 最坏情况向量生成
   - 片上电压监测
   - 自适应电压调节
   - 与功能模式相关性

2. **电源噪声注入**：
   - 可控的噪声源
   - 鲁棒性验证
   - 余量characterization
   - 老化效应评估

3. **多电源域测试**：
   - 电源序列验证
   - 域间隔离测试
   - 电平转换器验证
   - 省电模式转换

**低功耗DFT技术**：
- 扫描链分割和门控
- 测试数据压缩减少活动
- 智能测试调度
- 功耗感知ATPG

### 12.1.6 先进DFT技术

**压缩扫描技术**：
- EDT (Embedded Deterministic Test)：确定性测试压缩
- 压缩比：10-100倍，大幅减少测试时间和数据量
- 解压缩器：片上硬件，实时展开压缩数据
- X-tolerance：处理不确定响应的能力

**主流压缩技术对比**：
1. **线性压缩（EDT/XOR）**：
   - 原理：线性方程求解
   - 压缩比：50-100X
   - 硬件开销：<1%
   - X容忍度：中等
   - 工具支持：成熟

2. **广播扫描**：
   - 原理：扫描链共享
   - 压缩比：10-20X
   - 硬件开销：极小
   - 限制：相关性约束

3. **混合压缩**：
   - 结合多种技术
   - 自适应选择
   - 最优压缩比
   - 复杂度较高

**压缩效率的理论极限**：
- 信息论边界：基于测试集熵
- 实际限制：X状态、相关性
- 优化方向：更智能的编码
- 未来趋势：AI辅助压缩

**分层DFT架构**：
- 核心级DFT：每个IP核独立的测试结构
- 芯片级集成：IEEE 1500标准的核心测试包装
- 层次化测试调度：优化并行测试，减少总测试时间
- 测试访问机制（TAM）：优化测试数据传输路径

**IEEE 1500核心测试标准详解**：
1. **Wrapper架构**：
   - WBR（Wrapper Boundary Register）
   - WBY（Wrapper Bypass）
   - WIR（Wrapper Instruction Register）
   - 标准化的测试接口

2. **测试模式**：
   - InTest：核心内部测试
   - ExTest：核心间互连测试
   - Bypass：快速通过
   - 用户定义模式

3. **TAM优化策略**：
   - 带宽分配算法
   - 测试调度优化
   - 功耗约束考虑
   - 热点避免

**分层测试的挑战与解决**：
- 测试隔离：防止故障传播
- 诊断精度：层次化故障定位
- 集成复杂度：自动化工具支持
- 验证完整性：分层验证策略

**3D IC测试挑战**：
- TSV (Through-Silicon Via) 测试：新的故障模型
- 层间测试：pre-bond、mid-bond、post-bond测试
- 热管理：3D堆叠的散热挑战
- 测试成本优化：减少KGD (Known Good Die) 测试

**3D IC特有的故障模型**：
1. **TSV故障**：
   - 开路：制造缺陷、热应力
   - 短路：邻近TSV桥接
   - 泄漏：绝缘层缺陷
   - RC延迟：几何变化

2. **热相关故障**：
   - 热点形成
   - 热迁移效应
   - 层间热耦合
   - 动态热管理

3. **机械应力故障**：
   - 晶圆薄化影响
   - 键合应力
   - CTE不匹配
   - 封装翘曲

**3D测试策略创新**：
- 内建TSV测试电路
- 层间通信协议测试
- 热感知测试调度
- 分层诊断和修复
- 测试复用架构

**自适应测试**：
- 基于机器学习的测试优化
- 动态调整测试流程和参数
- 预测性维护和可靠性评估
- 实时故障诊断和yield学习

**机器学习在DFT中的应用**：
1. **测试向量优化**：
   - 神经网络预测故障热点
   - 强化学习优化测试序列
   - 聚类分析识别相似故障
   - 迁移学习跨产品应用

2. **良率预测和优化**：
   - 早期良率预测模型
   - 制程参数相关性分析
   - 自适应测试限值
   - 实时反馈控制

3. **诊断智能化**：
   - 故障特征自动提取
   - 根因分析加速
   - 知识图谱构建
   - 专家系统集成

**未来DFT技术展望**：
- 量子计算测试方法
- 神经形态芯片测试
- 自组装系统测试
- 生物启发的自修复
- 认知测试系统

### 练习 12.1

1. 计算一个简单组合电路的SCOAP可测试性度量。

<details>
<summary>参考答案</summary>

SCOAP可测试性计算示例：

考虑电路：Z = A·B + C·D

**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**可控制性计算（从输入到输出）**：

初始化输入：
- CC0(A) = CC1(A) = 1
- CC0(B) = CC1(B) = 1  
- CC0(C) = CC1(C) = 1
- CC0(D) = CC1(D) = 1

AND1门（A·B）：
- CC0(AND1) = min{CC0(A), CC0(B)} + 1 = min{1,1} + 1 = 2
- CC1(AND1) = CC1(A) + CC1(B) + 1 = 1 + 1 + 1 = 3

AND2门（C·D）：
- CC0(AND2) = min{CC0(C), CC0(D)} + 1 = 2
- CC1(AND2) = CC1(C) + CC1(D) + 1 = 3

OR门（Z）：
- CC0(Z) = CC0(AND1) + CC0(AND2) + 1 = 2 + 2 + 1 = 5
- CC1(Z) = min{CC1(AND1), CC1(AND2)} + 1 = min{3,3} + 1 = 4

**可观察性计算（从输出到输入）**：

初始化输出：
- CO(Z) = 1

反向传播：
OR门到AND门：
- CO(AND1) = CO(Z) + CC0(AND2) + 1 = 1 + 2 + 1 = 4
- CO(AND2) = CO(Z) + CC0(AND1) + 1 = 1 + 2 + 1 = 4

AND门到输入：
- CO(A) = CO(AND1) + CC1(B) + 1 = 4 + 1 + 1 = 6
- CO(B) = CO(AND1) + CC1(A) + 1 = 4 + 1 + 1 = 6
- CO(C) = CO(AND2) + CC1(D) + 1 = 4 + 1 + 1 = 6  
- CO(D) = CO(AND2) + CC1(C) + 1 = 4 + 1 + 1 = 6

**可测试性分析**：
- 所有输入的可观察性相同，无特别难测试的节点
- Z的设0比设1困难（5 vs 4），符合OR门特性
- 总体可测试性良好，无需额外测试点
</details>

2. 设计一个4位计数器的扫描链结构。

<details>
<summary>参考答案</summary>

4位计数器扫描链设计：

**原始计数器结构**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**扫描触发器设计**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**完整扫描链连接**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**控制信号**：
- SE=0：正常功能模式
- SE=1：扫描测试模式

**测试过程**：
1. **扫描载入阶段**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **功能执行阶段**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **扫描卸载阶段**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试向量示例**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**优势**：
- 100%内部状态可控/可观
- 测试向量生成简化
- 可测试任意组合逻辑故障
- 支持延迟故障测试

**开销**：
- 每个FF增加1个2选1MUX
- 额外的扫描控制信号
- 约5-10%面积开销
- 扫描时间开销（4个时钟周期）
</details>

3. 分析不同DFT技术的成本效益权衡。

<details>
<summary>参考答案</summary>

DFT技术成本效益分析：

**1. 全扫描设计**
- 成本：5-10%面积开销，10-15%功耗增加
- 效益：>99%故障覆盖率，ATPG简化
- ROI：最高，工业标准
- 适用：大多数数字电路

**2. 部分扫描**
- 成本：2-5%面积开销
- 效益：90-95%故障覆盖率
- ROI：中等，需要更复杂的ATPG
- 适用：面积敏感的设计

**3. BIST**
- 成本：3-8%面积开销（取决于电路类型）
- 效益：高速测试，现场测试能力
- ROI：高（大批量生产）
- 适用：存储器、规则结构

**4. 压缩扫描**
- 成本：1-3%额外面积（解压缩器）
- 效益：10-100倍测试数据减少
- ROI：非常高（测试时间大幅减少）
- 适用：大规模SoC

**决策矩阵**：
- 小规模ASIC：全扫描
- 消费类SoC：压缩扫描+BIST
- 汽车/航空：全面DFT+在线测试
- IoT设备：部分扫描+关键BIST

**成本计算示例**：
假设1M门设计，10M单元产量
- 无DFT：50%良率，测试时间10s
- 全扫描：85%良率，测试时间1s
- 投资回报：6个月内回收DFT开销
</details>

### 进一步研究

- 低功耗扫描设计技术：扫描移位功耗优化
- 压缩扫描和X-masking：下一代压缩技术
- 3D集成电路的测试挑战：新兴的测试方法学
- 人工智能在DFT优化中的应用：智能测试点选择
- 量子计算对硬件测试的影响
- 近阈值电压设计的测试挑战
- 硅光子集成电路的测试方法

## 12.2 内建自测试（BIST）

内建自测试通过在芯片内部集成测试生成和响应分析电路，实现测试的自主化和高效化。

### 12.2.1 BIST基本架构

**BIST的驱动因素**：
- 测试成本持续上升：ATE设备价格昂贵（$1M-$5M）
- 测试访问受限：封装后的芯片引脚有限
- 现场测试需求：系统级健康监测
- 高速测试要求：GHz级信号难以从外部施加

**核心组件详解**：

1. **测试模式生成器（TPG）**：
   - 伪随机生成器：LFSR、CA（细胞自动机）
   - 确定性生成器：ROM、计数器
   - 混合生成器：伪随机+确定性种子
   - 自适应生成器：基于覆盖率反馈

2. **待测电路（CUT）**：
   - 组合逻辑：直接测试
   - 时序逻辑：通过扫描链或功能测试
   - 存储器：专用算法
   - 模拟/混合信号：专门的BIST方案

3. **响应分析器（RA）**：
   - 签名分析：MISR、LFSR
   - 比较器：golden reference
   - 计数器：1的个数、转换计数
   - 校验和：CRC、奇偶校验

4. **BIST控制器**：
   - 有限状态机：控制测试序列
   - 计数器：控制测试长度
   - 配置寄存器：测试模式选择
   - 接口逻辑：与外部通信

**典型BIST流程**：
1. 初始化：复位CUT和BIST电路
2. 配置：设置测试模式和参数
3. 执行：生成测试向量并施加
4. 捕获：收集CUT响应
5. 分析：压缩响应为签名
6. 诊断：比较签名并报告结果

### 12.2.2 伪随机测试生成

**线性反馈移位寄存器（LFSR）**：
- 生成伪随机序列
- 硬件实现简单
- 最大长度序列特性

**LFSR设计要点**：

1. **本原多项式选择**：
   - 保证最大长度序列（2^n-1）
   - 常用多项式表：IEEE标准参考
   - 抽头位置优化：最少异或门

2. **LFSR类型**：
   - 外部反馈（Fibonacci）：适合并行输出
   - 内部反馈（Galois）：更高速度
   - 模块化LFSR：易于扩展

3. **种子选择策略**：
   - 避免全0（锁定状态）
   - 目标故障导向种子
   - 多种子技术：提高覆盖率

4. **增强技术**：
   - 相位移位器：生成低相关序列
   - 重新播种：定期更新种子
   - 位翻转：增加0/1平衡

**种子依赖性问题**：
- 全0状态为吸收态
- 需要避免或处理全0种子
- 可采用修正的LFSR结构

**加权伪随机生成**：

1. **权重分配方法**：
   - 信号概率分析：基于电路结构
   - 故障模拟导向：迭代优化权重
   - 机器学习：自动权重学习

2. **实现技术**：
   - 偏置LFSR：修改反馈函数
   - 加权逻辑：AND/OR门网络
   - 可编程权重：运行时调整

3. **多权重集合**：
   - 时间复用：不同测试阶段不同权重
   - 空间复用：不同电路部分不同权重
   - 自适应切换：基于覆盖率进展

4. **效果评估**：
   - 典型提升：20-50%测试长度减少
   - 硬件开销：5-15%额外面积
   - 适用场景：随机抗性电路

### 12.2.3 响应压缩技术

**多输入移位寄存器（MISR）**：
- 将多位响应压缩为固定长度
- 基于线性反馈移位寄存器
- 空间和时间双重压缩

**循环冗余码（CRC）**：
- 基于多项式除法
- 优秀的错误检测能力
- 标准化的生成多项式

**别名问题深入分析**：

1. **别名概率计算**：
   - 理想情况：2^(-n)，n为签名位数
   - 实际情况：取决于错误分布
   - 多重故障：别名概率增加

2. **别名减少技术**：
   - 增加签名长度：线性改善
   - 多重签名：不同多项式
   - 中间签名：定期采样
   - 错误计数：辅助诊断

3. **零别名技术**：
   - 空间压缩+时间展开
   - 确定性选择压缩
   - 代价：更多硬件/时间

4. **实践考虑**：
   - 32位签名：10^-10别名概率
   - 64位签名：工业标准
   - 诊断需求：保留部分原始信息

**时间压缩考虑**：
- 压缩序列与原始序列的关系
- 错误传播和累积效应
- 最优压缩策略

### 12.2.4 存储器BIST

**存储器故障模型**：
- 固定故障（SAF）：单元固定为0或1
- 转换故障（TF）：无法改变状态
- 耦合故障（CF）：单元间相互影响
- 地址故障：地址译码错误
- 数据保持故障：动态失效

**March算法家族详解**：

1. **March符号系统**：
   - ⇑：地址递增
   - ⇓：地址递减
   - ⇕：地址任意顺序
   - w0/w1：写0/1操作
   - r0/r1：读0/1操作

2. **经典March算法**：
   - MATS+：{⇕(w0); ⇑(r0,w1); ⇓(r1,w0)}
   - March C-：{⇕(w0); ⇑(r0,w1); ⇑(r1,w0); ⇓(r0,w1); ⇓(r1,w0); ⇕(r0)}
   - March A：{⇕(w0); ⇑(r0,w1,w0,w1); ⇑(r1,w0,w1); ⇓(r1,w0,w1,w0); ⇓(r0,w1,w0)}

3. **故障覆盖能力**：
   - SAF：所有March算法100%
   - TF：March C-及以上100%
   - CFin：需要特定读写序列
   - CFid/CFst：更复杂的算法

4. **新型March算法**：
   - March SS：检测静态和动态故障
   - March LR：低功耗优化
   - March SL：扫描链友好

**算法复杂度对比**：
- March C-：11n（线性）
- March B：17n
- March A：15n
- GALPAT：n²（平方）

### 12.2.5 逻辑BIST设计

**随机抗性分析**：

1. **抗性电路特征**：
   - 大扇入门（如32输入AND）
   - 深度组合路径
   - 特定值依赖（如解码器）
   - 反馈环路

2. **检测概率计算**：
   - 单个故障：Pd = P1 × P2 × ... × Pn
   - P1：激活概率
   - P2-Pn：传播概率
   - 典型抗性：Pd < 10^-6

3. **改善技术**：
   - 测试点插入：打破抗性
   - 部分扫描：增加可控性
   - 确定性种子：目标导向
   - 混合模式：随机+确定性

**测试点优化策略**：

1. **选择算法**：
   - 基于COP（可控性-可观察性乘积）
   - 梯度下降：最大改善/成本
   - 遗传算法：全局优化
   - 机器学习：模式识别

2. **插入类型**：
   - 控制点：0-控制、1-控制、翻转
   - 观察点：直接观察、XOR压缩
   - 混合点：同时改善C/O

3. **成本模型**：
   - 面积：门数、布线
   - 时序：关键路径影响
   - 功耗：活动率增加
   - 可测性：覆盖率提升

4. **工业实践**：
   - 典型数量：0.1-1%的节点
   - 覆盖率提升：5-15%
   - ROI：2-3倍测试时间减少

**多阶段BIST架构**：

1. **阶段划分策略**：
   - 阶段1：纯随机（80%故障）
   - 阶段2：加权随机（15%故障）
   - 阶段3：确定性（剩余5%）
   - 阶段4：诊断模式（可选）

2. **切换机制**：
   - 基于时间：固定周期数
   - 基于覆盖率：饱和检测
   - 混合：时间上限+覆盖率

3. **存储优化**：
   - 种子压缩：差分编码
   - 共享存储：复用ROM
   - 流水线：重叠执行

4. **性能指标**：
   - 测试时间：减少50-80%
   - 硬件开销：增加10-20%
   - 故障覆盖率：>99%
   - 诊断分辨率：提升3-5倍

### 12.2.6 低功耗BIST技术

**功耗挑战**：
- 测试功耗可达正常功耗的2-3倍
- 同时切换活动导致IR-drop
- 热点形成风险
- 可能导致良品误判

**低功耗BIST方案**：

1. **测试调度**：
   - 分区测试：降低并发活动
   - 交错时钟：错开切换时间
   - 功率感知调度：热管理

2. **向量生成优化**：
   - 低活动率LFSR：修改的反馈
   - 向量过滤：去除高功耗向量
   - 灰码计数器：最小切换

3. **扫描链分段**：
   - 部分激活：只启用部分链
   - 门控时钟：精细控制
   - 数据门控：减少翻转

4. **效果评估**：
   - 功耗降低：30-60%
   - 测试时间影响：<10%增加
   - 面积开销：5-10%
   - 覆盖率影响：可忽略

### 练习 12.2

1. 设计一个8位LFSR的BIST系统并分析其覆盖率。

<details>
<summary>参考答案</summary>

8位LFSR BIST系统设计：

**LFSR结构**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**完整BIST系统**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**MISR结构**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试流程**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**覆盖率分析**：

理论分析：
- 最大序列长度：2^8 - 1 = 255
- 8位输入空间：256种可能
- 覆盖率：255/256 = 99.6%
- 缺失：全0向量（通常不是问题）

实际考虑：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

典型覆盖率：
- 固定故障：95-98%
- 转换故障：90-95%
- 总体：93-97%

**优化策略**：
1. **多项式选择**：
   - 测试不同本原多项式
   - 选择覆盖率最高的

2. **种子优化**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **混合方法**：
   - LFSR伪随机测试（主要）
   - 确定性向量补充（剩余故障）

**性能指标**：
- 硬件开销：约20-30个逻辑门
- 测试时间：255个时钟周期
- 故障覆盖率：93-97%
- 别名概率：< 2^(-8) = 0.39%
</details>

2. 比较不同存储器测试算法的效果和复杂度。

<details>
<summary>参考答案</summary>

存储器测试算法对比分析：

**1. MATS (Modified Algorithmic Test Sequence)**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：4n
- 检测故障：固定故障、地址故障
- 优点：最简单、最快
- 缺点：故障覆盖有限

**2. March C-**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：11n
- 检测故障：SAF、TF、大部分CF、AF
- 优点：广泛使用、平衡的复杂度/覆盖率
- 缺点：不能检测所有耦合故障

**3. March B**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：17n
- 检测故障：包括March C-的所有故障，plus更多CF
- 优点：更高的故障覆盖率
- 缺点：时间开销更大

**4. March A**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：15n
- 检测故障：类似March B但略少
- 平衡性：介于March C-和March B之间

**5. GALPAT (Galloping Pattern)**

算法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

特性：
- 复杂度：O(n²)
- 检测故障：几乎所有类型，包括复杂耦合
- 优点：最高的故障检测能力
- 缺点：时间复杂度太高，实用性差

**故障检测能力对比表**：

| 故障类型 | MATS | March C- | March A | March B | GALPAT |
|---------|------|----------|---------|---------|---------|
| 固定故障(SAF) | ✓ | ✓ | ✓ | ✓ | ✓ |
| 转换故障(TF) | ✗ | ✓ | ✓ | ✓ | ✓ |
| 反转耦合(CFin) | ✗ | ✓ | ✓ | ✓ | ✓ |
| 幂等耦合(CFid) | ✗ | ✓ | ✓ | ✓ | ✓ |
| 状态耦合(CFst) | ✗ | 部分 | 部分 | ✓ | ✓ |
| 桥接故障(BF) | ✗ | 部分 | 部分 | ✓ | ✓ |
| 地址故障(AF) | ✓ | ✓ | ✓ | ✓ | ✓ |

**复杂度和时间对比**：

| 算法 | 时间复杂度 | 实际操作数 | 相对时间 |
|------|-----------|-----------|----------|
| MATS | 4n | 4n | 1× |
| March C- | 11n | 11n | 2.75× |
| March A | 15n | 15n | 3.75× |
| March B | 17n | 17n | 4.25× |
| GALPAT | n² | 4n²+2n | 1000×(n=1M) |

**选择策略**：

**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**新兴算法和技术**：

1. **透明BIST**：
   - 在正常操作期间进行测试
   - 不中断系统功能
   - 连续监控内存健康

2. **自适应算法**：
   - 根据发现的故障调整测试策略
   - 机器学习指导的测试生成
   - 实时故障概率评估

3. **并行测试**：
   - 多个内存块同时测试
   - 分区测试策略
   - 减少总测试时间

实践建议：
- 通用应用：March C-
- 高可靠性：March B
- 快速筛选：MATS
- 关键系统：分层混合策略
</details>

3. 设计一个混合模式BIST系统，结合伪随机和确定性测试。

<details>
<summary>参考答案</summary>

混合模式BIST系统设计：

**系统架构**：
1. 伪随机测试模块（占80%测试时间）
   - 32位LFSR，本原多项式x^32+x^22+x^2+x+1
   - 10K周期，覆盖大部分易测故障
   
2. 确定性测试模块（占20%测试时间）
   - ROM存储关键测试向量（256个）
   - 针对随机抗性故障
   - 压缩存储，实时解压

3. 控制器设计：
   ```
   状态机：IDLE → RANDOM → DETERMINISTIC → DONE
   切换条件：时间或覆盖率饱和
   ```

4. 响应分析：
   - 双MISR：分别处理两种模式
   - 选择性压缩：保留诊断信息

**性能分析**：
- 故障覆盖率：99.5%（纯随机：85%）
- 测试时间：减少60%
- 硬件开销：15%（ROM主要开销）
- 诊断能力：可定位到模块级

**优化策略**：
1. 种子选择：基于故障模拟
2. ROM共享：与其他功能复用
3. 动态重配置：根据芯片类型
4. 分层测试：核心优先
</details>

### 进一步研究

- **新兴存储技术的测试挑战**：
  - ReRAM/MRAM的特殊故障模型
  - 3D NAND的层间耦合测试
  - 存算一体架构的BIST设计
  
- **低功耗BIST优化**：
  - 近阈值电压下的BIST可靠性
  - 动态电压频率调节（DVFS）兼容BIST
  - 能量采集系统的自供电BIST
  
- **机器学习在BIST中的应用**：
  - 测试向量智能生成
  - 自适应测试调度
  - 故障预测和健康监测
  - 良率学习和优化
  
- **在线测试和自修复**：
  - 并发BIST（运行时测试）
  - 预测性维护算法
  - 自适应冗余分配
  - 弹性计算架构
  
- **安全相关BIST**：
  - 防篡改测试结构
  - 侧信道攻击防护
  - 测试数据加密
  - 可信测试架构

## 12.3 边界扫描与JTAG

边界扫描是一种标准化的测试技术，通过IEEE 1149.1 JTAG标准，为电路板级和芯片级测试提供了统一的解决方案。

### 12.3.1 JTAG标准概述

**IEEE 1149.1标准**：
- 1990年发布的测试访问端口标准
- Joint Test Action Group的缩写
- 提供标准化的测试接口

**基本概念**：
- 在芯片的每个输入/输出管脚旁增加边界扫描单元
- 形成围绕芯片核心的扫描链
- 通过4线接口控制测试操作

**标准接口信号**：
- TCK（Test Clock）：测试时钟
- TMS（Test Mode Select）：模式选择
- TDI（Test Data In）：测试数据输入
- TDO（Test Data Out）：测试数据输出
- TRST（Test Reset）：测试复位（可选）

### 12.3.2 边界扫描架构

**边界扫描单元（BSC）**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**BSC工作模式**：
- 正常模式：信号正常传输
- 捕获模式：捕获引脚状态到扫描链
- 移位模式：扫描链数据移位
- 更新模式：将扫描数据施加到引脚

**典型BSC结构**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.3.3 测试访问端口（TAP）

**TAP控制器状态机**：
- 16个状态的有限状态机
- 通过TMS信号控制状态转换
- 协调指令和数据的操作

**关键状态**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**指令寄存器（IR）**：
- 存储当前测试指令
- 决定数据寄存器的连接
- 标准指令集和用户指令

### 12.3.4 标准测试指令

**BYPASS指令**：
- 最简单的测试指令
- 创建1位的数据路径
- 用于绕过不需要测试的器件

**SAMPLE/PRELOAD指令**：
- 采样所有边界扫描单元的当前值
- 预加载测试数据到输出单元
- 不干扰正常功能

**EXTEST指令**：
- 外部测试指令
- 控制和观察所有数字引脚
- 用于板级互连测试

**INTEST指令**：
- 内部测试指令
- 通过边界扫描访问内部逻辑
- 实现芯片内部的测试

### 12.3.5 板级测试应用

**互连测试**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试向量生成**：
- 基于网表信息
- 自动生成测试序列
- 故障字典方法

**诊断能力**：
- 精确定位故障位置
- 区分不同故障类型
- 提供修复指导

### 12.3.6 高级JTAG应用

**在系统编程（ISP）**：
- 通过JTAG接口编程Flash
- 固件更新和配置
- 制造阶段的编程

**调试支持**：
- 处理器调试接口
- 实时跟踪功能
- 断点和单步执行

**IEEE 1149.4扩展**：
- 模拟和混合信号测试
- 测试总线标准
- 模拟开关矩阵

### 练习 12.3

1. 设计一个简单的4引脚器件的JTAG边界扫描链。

<details>
<summary>参考答案</summary>

4引脚器件JTAG边界扫描设计：

**器件规格**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**边界扫描单元分配**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**JTAG接口**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**边界扫描链连接**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**输入BSC结构（以A[0]为例）**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**输出BSC结构（以Sum[0]为例）**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**TAP控制器状态**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**指令寄存器定义**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试序列示例**：

1. **功能测试**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **互连测试**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**边界扫描描述语言（BSDL）**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**测试覆盖率分析**：
- 引脚级短路/开路：100%
- 内部逻辑故障：取决于INTEST向量
- 互连故障：板级100%
- 时序故障：有限（准静态测试）
</details>

2. 分析JTAG在板级测试中的优势和限制。

<details>
<summary>参考答案</summary>

JTAG板级测试分析：

**优势分析**：

1. **标准化和互操作性**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **非侵入式测试**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **高故障诊断能力**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

4. **成本效益**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**限制分析**：

1. **测试速度限制**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **故障覆盖范围**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **器件依赖性**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

4. **复杂性管理**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**性能对比表**：

| 测试方面 | JTAG | ICT | 功能测试 | 飞针测试 |
|---------|------|-----|---------|----------|
| 互连覆盖 | 90-95% | 95-99% | 0-30% | 95-99% |
| 故障诊断 | 优秀 | 良好 | 一般 | 优秀 |
| 测试速度 | 慢 | 快 | 中等 | 慢 |
| 治具成本 | 低 | 高 | 中等 | 低 |
| 设置时间 | 短 | 长 | 中等 | 短 |
| 编程复杂度 | 中等 | 低 | 高 | 中等 |

**最佳应用场景**：

1. **适合JTAG的场景**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **不适合的场景**：
   **[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**混合测试策略**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**结论**：
JTAG是板级测试的重要工具，特别适合现代高密度电路板。虽然有速度和覆盖范围的限制，但其标准化、成本效益和诊断能力使其成为测试策略的核心组件。最佳实践是将JTAG与其他测试方法结合，发挥各自优势。
</details>

### 进一步研究

- IEEE 1149.1的后续标准发展
- 高速信号的边界扫描技术
- 嵌入式仪器标准（IEEE 1149.4/.6/.7）
- JTAG在安全和调试中的应用

## 12.4 故障模型

硬件故障模型是测试向量生成和故障覆盖率评估的理论基础。不同的物理缺陷在逻辑层面表现为不同的故障模型。

### 12.4.1 固定故障模型

**单固定故障（Single Stuck-At Fault, SAF）**：
- 信号线固定为逻辑0（sa0）或逻辑1（sa1）
- 经典且最重要的故障模型
- 对应多种物理缺陷

**物理对应关系**：
- 金属线开路→输入sa0/sa1
- 晶体管漏极开路→输出sa0
- 电源短路→sa1
- 接地短路→sa0

**故障数量计算**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**检测条件**：
为检测线路L的sa0故障：
1. 将L设置为1（激活）
2. 将故障效应传播到输出（传播）
3. 在输出观察到差异

### 12.4.2 桥接故障模型

**桥接故障定义**：
- 两条或多条信号线意外连接
- 反映实际制造中的金属桥接缺陷
- 比固定故障更真实

**桥接故障类型**：

1. **主导桥接（Dominant Bridging）**：
   - 一个信号主导另一个
   - 通常强驱动覆盖弱驱动

2. **线与桥接（Wired-AND）**：
   - 桥接结果为两信号的逻辑与
   - 任一信号为0，结果为0

3. **线或桥接（Wired-OR）**：
   - 桥接结果为两信号的逻辑或
   - 任一信号为1，结果为1

**桥接故障检测**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.4.3 延迟故障模型

**延迟故障类型**：

1. **路径延迟故障（Path Delay Fault）**：
   - 整条路径延迟超过时钟周期
   - 反映路径上所有门的累积延迟

2. **转换延迟故障（Transition Delay Fault）**：
   - 单个门的延迟故障
   - 慢速上升（slow-to-rise）
   - 慢速下降（slow-to-fall）

3. **门延迟故障（Gate Delay Fault）**：
   - 特定门的输入到输出延迟异常
   - 可以是特定输入的延迟

**延迟故障检测**：
- 需要两个时间帧的向量对
- V1：初始化路径为稳定值
- V2：启动转换并在时钟边沿观察

**at-speed测试**：
- 使用功能时钟频率
- 检测实际工作条件下的时序故障
- 比静态测试更真实

### 12.4.4 IDDQ测试

**静态电流测试原理**：
- CMOS电路静态时电流应该很小（nA级）
- 某些故障导致异常电流（mA级）
- 通过测量电源电流检测故障

**可检测故障**：
- 栅极氧化层短路
- 漏极/源极桥接
- 某些固定故障
- 亚阈值泄漏

**IDDQ测试挑战**：
- 工艺技术缩小导致泄漏电流增大
- 深亚微米工艺中应用受限
- 需要特殊的测试设备

### 12.4.5 存储器故障模型

**单元故障**：
- 固定故障：单元固定为0或1
- 转换故障：无法从0变1或从1变0
- 数据保持故障：动态失效

**耦合故障**：
- 反转耦合：一个单元影响另一个单元状态
- 幂等耦合：写操作影响邻近单元
- 状态耦合：读操作影响其他单元

**地址故障**：
- 地址译码器故障
- 访问错误单元
- 多个单元同时被选中

### 练习 12.4

1. 设计测试向量检测一个2输入与门的所有固定故障。

<details>
<summary>参考答案</summary>

2输入与门固定故障分析：

**电路：Z = A · B**

**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**故障列表**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**故障检测分析**：

1. **A sa0故障**：
   - 故障电路：Z = 0 · B = 0
   - 正常电路：Z = A · B
   - 检测条件：需要A=1，且使正常输出≠0
   - 检测向量：A=1, B=1 → 正常输出Z=1，故障输出Z=0

2. **A sa1故障**：
   - 故障电路：Z = 1 · B = B
   - 正常电路：Z = A · B
   - 检测条件：需要A=0，使A·B≠B
   - 检测向量：A=0, B=1 → 正常输出Z=0，故障输出Z=1

3. **B sa0故障**：
   - 故障电路：Z = A · 0 = 0
   - 检测向量：A=1, B=1 → 正常输出Z=1，故障输出Z=0

4. **B sa1故障**：
   - 故障电路：Z = A · 1 = A
   - 检测向量：A=1, B=0 → 正常输出Z=0，故障输出Z=1

5. **Z sa0故障**：
   - 故障电路：Z = 0（无论输入如何）
   - 检测条件：正常输出为1
   - 检测向量：A=1, B=1 → 正常输出Z=1，故障输出Z=0

6. **Z sa1故障**：
   - 故障电路：Z = 1（无论输入如何）
   - 检测条件：正常输出为0
   - 检测向量：A=0, B=0 → 正常输出Z=0，故障输出Z=1
   - 或者：A=0, B=1 → 正常输出Z=0，故障输出Z=1
   - 或者：A=1, B=0 → 正常输出Z=0，故障输出Z=1

**测试向量集合**：

完整测试向量（4个向量，覆盖所有故障）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**最小测试向量集**：

分析哪些向量是必需的：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

最小向量集（3个向量）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**故障覆盖表**：

| 向量 | A | B | Z正常 | A sa0 | A sa1 | B sa0 | B sa1 | Z sa0 | Z sa1 |
|------|---|---|-------|-------|-------|-------|-------|-------|-------|
| V1   | 0 | 1 | 0     | -     | ✓     | -     | ✓     | -     | ✓     |
| V2   | 1 | 0 | 0     | -     | -     | -     | ✓     | -     | ✓     |  
| V3   | 1 | 1 | 1     | ✓     | -     | ✓     | -     | ✓     | -     |

**验证**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**通用结论**：
- 与门的完整故障检测需要至少3个向量
- 包含真值表中能产生1的输入组合（检测sa0故障）
- 包含能产生0的输入组合（检测sa1故障）
- 每个输入都要在0和1状态下测试
</details>

2. 分析为什么延迟故障比固定故障更难检测。

<details>
<summary>参考答案</summary>

延迟故障检测困难性分析：

**1. 检测条件复杂性**

固定故障检测：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障检测：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**2. 路径敏化问题**

固定故障：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**3. 时序复杂性**

固定故障（静态）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障（动态）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**4. 故障传播问题**

固定故障传播：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障传播：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**5. 向量生成复杂度**

固定故障ATPG：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障ATPG：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**6. 测试成本**

固定故障测试：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障测试：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**7. 诊断复杂性**

固定故障诊断：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

延迟故障诊断：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**结论**：

延迟故障检测困难的根本原因：
1. **维度增加**：从空间（逻辑）扩展到时间（时序）
2. **约束复杂**：多个相互关联的约束条件
3. **连续性**：延迟是连续参数，不是离散逻辑值
4. **工艺敏感**：受制造工艺变化影响大
5. **设备要求**：需要复杂昂贵的测试设备

这解释了为什么业界仍以固定故障为主要测试目标，延迟故障测试主要用于关键应用和高性能电路。
</details>

### 进一步研究

- 纳米工艺中的新兴故障模型
- 软错误和单粒子翻转
- 老化相关的故障机制
- 机器学习在故障建模中的应用

## 12.5 自动测试图案生成（ATPG）

自动测试图案生成是硬件测试的核心技术，通过算法自动生成能够检测特定故障的测试向量。

### 12.5.1 ATPG问题定义

**基本问题**：
给定电路和故障列表，自动生成测试向量集合，使得：
- 最大化故障覆盖率
- 最小化测试向量数量
- 满足时间和计算资源约束

**问题复杂性**：
- NP完全问题
- 搜索空间：2^n（n为输入数）
- 需要启发式算法

### 12.5.2 D算法

**基本思想**：
- 将故障激活和传播问题转化为逻辑约束求解
- 使用D代数扩展常规逻辑
- 系统化搜索测试向量

**D代数**：
- 0, 1：正常逻辑值
- D：正常为1，故障为0
- D̄：正常为0，故障为1
- X：未知值

**D算法步骤**：
1. **故障激活**：在故障位置产生D或D̄
2. **D传播**：将D值传播到主输出
3. **线路赋值**：设置其他输入以保证传播
4. **一致性检查**：验证赋值无矛盾

**D传播规则**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.5.3 FAN算法

**改进动机**：
- D算法回溯次数过多
- 需要更智能的搜索策略
- 提高算法效率

**关键改进**：

1. **多重回溯**：
   - 同时尝试多个赋值
   - 避免过早的错误决策
   - 减少回溯深度

2. **唯一敏化**：
   - 优先选择唯一敏化路径
   - 减少搜索分支
   - 提高成功概率

3. **头线识别**：
   - 找出影响多个目标的关键线路
   - 优先处理头线
   - 加速收敛

**FAN算法流程**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.5.4 基于SAT的ATPG

**SAT建模优势**：
- 将ATPG问题转化为布尔可满足性问题
- 利用现代SAT求解器的强大能力
- 处理复杂约束和优化目标

**编码方法**：

1. **电路结构编码**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

2. **故障效应编码**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

3. **时间帧展开**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 12.5.5 压缩测试

**动机**：
- 测试向量数量巨大
- 测试时间和存储成本高
- 需要减少测试数据量

**压缩技术**：

1. **测试向量压缩**：
   - 线性反馈移位寄存器（LFSR）
   - 种子压缩
   - 统计编码

2. **响应压缩**：
   - 多输入移位寄存器（MISR）
   - 循环冗余码（CRC）
   - 时间和空间压缩

3. **X值处理**：
   - 未知值影响压缩效果
   - X-masking技术
   - X-tolerant压缩

**压缩比计算**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

### 练习 12.5

1. 使用D算法为一个简单电路生成测试向量。

<details>
<summary>参考答案</summary>

D算法测试向量生成示例：

**目标电路**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

逻辑表达式：Z = (A·B) + (C·D) = E + F

**目标故障**：E线路sa0 (E stuck-at 0)

**D算法求解过程**：

**步骤1：故障激活**
- 故障：E sa0
- 正常情况：E = A·B  
- 故障情况：E = 0
- 激活条件：使A·B = 1，即A=1, B=1
- 故障激活后：E正常=1, E故障=0，表示为E=D

当前赋值：A=1, B=1, E=D

**步骤2：D传播**
- 目标：将E的D值传播到输出Z
- Z = E + F = D + F
- 传播条件：需要F不能掩盖D
- 对于OR门，要传播D，需要F=0
- 因此设置：F = 0

更新赋值：A=1, B=1, E=D, F=0

**步骤3：确定F=0的条件**
- F = C·D = 0
- 满足条件：C=0 或 D=0（或两者都为0）
- 选择：C=0, D=X（D可以是任意值）

更新赋值：A=1, B=1, C=0, D=X, E=D, F=0

**步骤4：计算输出值**
- Z = E + F = D + 0 = D
- 正常电路：Z = 1
- 故障电路：Z = 0
- 检测成功！

**最终测试向量**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**D算法详细追踪表**：

| 步骤 | 操作 | A | B | C | D | E | F | Z | 备注 |
|------|------|---|---|---|---|---|---|---|------|
| 0 | 初始 | X | X | X | X | X | X | X | 全部未知 |
| 1 | 激活E sa0 | 1 | 1 | X | X | D | X | X | A·B=1产生D |
| 2 | 传播到Z | 1 | 1 | X | X | D | 0 | X | F=0确保传播 |
| 3 | 确定F=0 | 1 | 1 | 0 | X | D | 0 | X | C=0使F=0 |
| 4 | 计算输出 | 1 | 1 | 0 | 0 | D | 0 | D | D传播到输出 |

**其他可能的解**：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**算法特点总结**：
1. **系统性**：D算法提供了系统化的搜索方法
2. **完备性**：如果存在测试向量，D算法最终能找到
3. **复杂性**：对于大电路，搜索空间仍然很大
4. **优化空间**：可以通过启发式改进（如FAN算法）

**扩展：检测其他故障**：

对于F线路sa1故障：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

这个例子展示了D算法的核心思想：故障激活→差异传播→一致性求解。
</details>

2. 比较传统ATPG和基于SAT的ATPG方法。

<details>
<summary>参考答案</summary>

传统ATPG vs SAT-based ATPG对比分析：

**1. 算法基础**

传统ATPG（D算法/FAN）：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

SAT-based ATPG：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**2. 问题建模方式**

传统方法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

SAT方法：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**3. 处理复杂性能力对比**

传统ATPG局限性：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

SAT-based优势：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**4. 性能比较**

运行时间：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

内存使用：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**5. 实际应用对比**

工业应用统计：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**6. 混合方案**

现代商业工具通常采用混合策略：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**7. 未来发展趋势**

技术融合：
**[扫描设计架构：通过扫描触发器构建测试访问机制，实现100%的寄存器状态可控制性和可观察性]**

**选择建议**：

| 场景 | 推荐方法 | 理由 |
|------|----------|------|
| 快速原型 | 传统ATPG | 工具成熟，速度快 |
| 复杂约束 | SAT-based | 约束处理能力强 |
| 大规模电路 | 混合方法 | 平衡效率和能力 |
| 研究新算法 | SAT-based | 易于扩展和实验 |
| 产品化工具 | 混合方法 | 覆盖所有应用场景 |

总结：传统ATPG和SAT-based方法各有优势，现代趋势是智能融合两者，根据具体问题特征选择最适合的方法。
</details>

### 进一步研究

- 量子计算在ATPG中的应用
- 机器学习辅助的测试向量优化
- 安全性意识的测试生成
- 低功耗测试的约束满足

## 本章小结

硬件和芯片测试代表了测试技术的高度工程化应用。本章我们探讨了：

1. **可测试性设计**：通过设计阶段的考虑提高测试效率
2. **内建自测试**：在硬件内部集成测试能力
3. **边界扫描**：标准化的测试接口和方法
4. **故障模型**：从物理缺陷到逻辑抽象的建模
5. **自动测试生成**：算法化的测试向量生成

硬件测试的独特挑战：
- 物理缺陷的多样性
- 制造规模和成本压力
- 实时性能要求
- 永久性故障的严重性

与软件测试的对比：
- 更强调物理层面的故障
- 更注重测试的经济性
- 更依赖专用的测试设备
- 更严格的正确性要求

技术发展趋势：
- 人工智能在测试优化中的应用
- 新兴工艺带来的测试挑战
- 在线测试和自修复技术
- 安全测试的重要性提升

下一章，我们将探讨机器学习系统测试，看看这些传统的测试理念如何适应AI时代的新挑战。